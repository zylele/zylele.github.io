[{"title":"EJB与JNDI","url":"/2016/04/04/EJB%E4%B8%8EJNDI/","content":"应用驱动学习\n（摊手）\n第一次接触使用EJB构建项目部署。\nEJB(Enterprise JavaBean)是sun的JavaEE服务器端组件模型和“最佳实践（讲真，即使EJB3.0已经借鉴了Spring等优点，在我看来还是臃肿繁琐），设计目标与核心应用是部署分布式应用程序。\n\n凭借java跨平台的优势，用EJB技术部署的分布式系统可以不限于特定的平台。EJB是J2EE的一部分，定义了一个用于开发基于组件的企业多重应用程序的标准。其特点包括网络服务支持和核心开发工具(SDK)。 在J2EE里，Enterprise Java Beans(EJB)称为Java企业Bean，是Java的核心代码，分别是会话Bean（Session Bean），实体Bean（Entity Bean）和消息驱动Bean（MessageDriven Bean）。\n\n\n作为Java WEB项目构建，可以简单这么理解其工作流程：\nJSP → Servlet → Session Bean或MessageDriven Bean → Entity Bean → DB持久化\n…\n（Spring不知道比它高到哪里去了）\nJNDI(The Java Naming and Directory Interface，Java 命名和目录接口) 是一组在Java 应用中访问命名和目录服务的API。为开发人员提供了查找和访问各种命名和目录服务的通用、统一的方式。借助于JNDI 提供的接口，能够通过名字定位用户、机器、网络、对象服务等。\n与EJB通信必须借助JNDI的命名服务查找使用相关的Bean，其中：\nlocal是本地接口，remote是远程接口。web层调用app层使用remote接口。session bena和entity bean之间\n调用使用的是local接口。\n因为JNDI是一组接口，所以我们只需根据接口规范编程就可以。要通过JNDI 进行资源访问，我们必须设置初始化上下文的参数，主要是设置JNDI 驱动的类名(java.naming.factory.initial) 和提供命名服务的URL (java.naming.provider.url)。\n因为Jndi 的实现产品有很多。所以java.naming.factory.initial 的值因提供JNDI 服务器的不同而不同，java.naming.provider.url 的值包括提供命名服务的主机地址和端口号。\n访问Jboss 服务器的例子代码：\nProperties props = new Properties();props.setProperty(&quot;java.naming.factory.initial&quot;, &quot;org.jnp.interfaces.NamingContextFactory&quot;);props.setProperty(&quot;java.naming.provider.url&quot;, &quot;localhost:1099&quot;);InitialContext ctx = new InitialContext(props);HelloWorld helloworld = (HelloWorld) ctx.lookup(&quot;HelloWorldBean/remote&quot;);\n不用说你也明白，remote接口对性能的影响是很大的。所以在设计的时候我们应尽量使用local接口，也就是facade模式。具体来说是，web层调用app层的session bean,session bean在调用各个实体entity bean。\nlocal接口可以在与ejb同一个jvm环境中调用，但是不能对它进行远程调用的，在jndi查找的时候不能查找local home，而要查找remote home，也就是说需要实际进行RMI调用，而且必须提供Provider URL(例如t3://myserver:7001)，而且他们返回给客户的对象也不一样，local home创建的是javax.ejb.EJBLocalObject类型，它没有继承Remote interface；而Remote home创建的是javax.ejb.EJBObject类型的，它扩展了Remote。\n实际上javax.ejb.EJBLoclObject型接口没有抛出RemoteException，因为对local类型接口的调用不是RMI，所以对Local接口的调用效率要高于对remote对象的调用，针对这点对EJB的设计提出以下建议：\n\n\n如果你的ejb客户只可能存在于与ejb相同app server，或者说同一个JVM环境中时，你可以只生成local类型接口（包括EJBHome 与EJBObject），如果你需要在与EJB容器不同的JVM环境中调用你的EJB的话，你必须生成Remote类型的接口（包括EJBHome 与EJBObject）。\n\n\n在一般情况下建议两种类型的接口（包括EJBHome 与EJBObject）都生成，尤其是Session Bean，Entity Bean，可以只生成local类型的接口，如果想远程调用你的Entity Bean一般用Session Bean做代理。\n\n\n如果你不是远程调用EJB的话，使用EJB时建议调用local接口，这样效率高，因为远程调用就意味着建立网络连接，效率必然不如local调用。\n\n\n在Java EE 7中设计EJB时，默认情况下只给你生成local类型接口，所以你需要在设计EJB时把interfaces设成：local/remote，这样的话你的EJB至少会有5个java文件\n\n\n","tags":["EJB"]},{"title":"Spring Boot多数据源切换与事务控制","url":"/2016/09/04/Spring%20Boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E4%B8%8E%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/","content":"后台数据库读写分离，不光是要配置多个数据源，还得能灵活动态的切换数据源，很好，目前都没问题，然而如果你的应用是使用SpringBoot：\n\nSpringBoot使我们更容易去创建基于Spring的独立和产品级的可以“即时运行”的应用和服务。支持约定大于配置，目的是尽可能快地构建和运行Spring应用。\n\n来初始化构建你的工程，引入多数据源将可能会导致事务无效的问题本文重点。因为传统通过xml手动配置更精准，出错也容易查找原因，然而交给SpringBoot自动帮你完成大部分的配置，绝逼满满的都是坑(我的直觉\n\n好，以下正题。\n(本文持久层框架使用MyBatis)\n\n简单的架构是：单个数据源绑定给sessionFactory，再在Dao层操作\n\n\n\n若多个数据源的话\n\n\n\nsessionFactory都写死在了Dao层，若我再添加个数据源的话，则又得添加一个sessionFactory，这样并不能扩展嘛，所以\n\n\n这样才是坠吼的！\n¶多数据源实现原理：\n¶配置文件\n精简篇幅，省略了无关本内容主题的配置\n本工程关于数据源的配置在pom.xml，部署各种环境应用不同的数据源，测试两个数据库test1和test2的配置\n&lt;properties&gt;    &lt;!-- 驱动 --&gt;    &lt;master.jdbc.driver&gt;com.mysql.jdbc.Driver&lt;/master.jdbc.driver&gt;    &lt;!-- JDBC URL --&gt;    &lt;master.jdbc.url&gt;jdbc:mysql://localhost/test1?useUnicode=true&amp;amp;autoReconnect=true&lt;/master.jdbc.url&gt;    &lt;!-- 数据库用户名 --&gt;    &lt;master.jdbc.username&gt;root&lt;/master.jdbc.username&gt;    &lt;!-- 数据库密码 --&gt;    &lt;master.jdbc.password&gt;root&lt;/master.jdbc.password&gt;    &lt;!-- 连接池最小连接数 --&gt;    &lt;master.db.pool.min&gt;10&lt;/master.db.pool.min&gt;    &lt;!-- 连接池初始连接数 --&gt;    &lt;master.db.pool.init&gt;10&lt;/master.db.pool.init&gt;    &lt;!-- 连接池最大连接数 --&gt;    &lt;master.db.pool.max&gt;20&lt;/master.db.pool.max&gt;    &lt;!-- 驱动 --&gt;    &lt;slave.jdbc.driver&gt;com.mysql.jdbc.Driver&lt;/slave.jdbc.driver&gt;    &lt;!-- JDBC URL --&gt;    &lt;slave.jdbc.url&gt;jdbc:mysql://localhost/test2?useUnicode=true&amp;amp;autoReconnect=true&lt;/slave.jdbc.url&gt;    &lt;!-- 数据库用户名 --&gt;    &lt;slave.jdbc.username&gt;root&lt;/slave.jdbc.username&gt;    &lt;!-- 数据库密码 --&gt;    &lt;slave.jdbc.password&gt;root&lt;/slave.jdbc.password&gt;    &lt;!-- 连接池最小连接数 --&gt;    &lt;slave.db.pool.min&gt;10&lt;/slave.db.pool.min&gt;    &lt;!-- 连接池初始连接数 --&gt;    &lt;slave.db.pool.init&gt;10&lt;/slave.db.pool.init&gt;    &lt;!-- 连接池最大连接数 --&gt;    &lt;slave.db.pool.max&gt;20&lt;/slave.db.pool.max&gt;&lt;/properties&gt;\napplication.properties，由SpringBoot自动加载相关属性\nmaster.datasource.name=masterDataSourcemaster.datasource.url=@master.jdbc.url@master.datasource.username=@master.jdbc.username@master.datasource.password=@master.jdbc.password@master.datasource.driver-class-name=@master.jdbc.driver@master.datasource.max-idle=@master.db.pool.max@master.datasource.min-idle=@master.db.pool.min@master.datasource.initial-size=@master.db.pool.init@master.datasource.validation-query=select 1master.datasource.test-on-borrow=truemaster.datasource.test-while-idle=trueslave.datasource.name=slaveDataSourceslave.datasource.url=@slave.jdbc.url@slave.datasource.username=@slave.jdbc.username@slave.datasource.password=@slave.jdbc.password@slave.datasource.driver-class-name=@slave.jdbc.driver@slave.datasource.max-idle=@slave.db.pool.max@slave.datasource.min-idle=@slave.db.pool.min@slave.datasource.initial-size=@slave.db.pool.init@slave.datasource.validation-query=select 1slave.datasource.test-on-borrow=trueslave.datasource.test-while-idle=true\ntransaction.xml配置需要事务控制的service\n&lt;!-- AOP配置--&gt;&lt;aop:config&gt;    &lt;!--pointcut元素定义一个切入点，execution中的第一个星号 用以匹配方法的返回类型，这里星号表明匹配所有返回类型。    com.abc.dao.*.*(..)表明匹配com.abc.dao包下的所有类的所有方法--&gt;    &lt;aop:pointcut id=&quot;transactionPointCut&quot; expression=&quot;execution(* cn.abc.lele.*.service.impl..*.*(..))&quot; /&gt;    &lt;!--将定义好的事务处理策略应用到上述的切入点--&gt;    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;transactionPointCut&quot; /&gt;&lt;/aop:config&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot; &gt;    &lt;tx:attributes&gt;    &lt;!--所有以find开头的方法都是只读的--&gt;    &lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot; /&gt;    &lt;tx:method name=&quot;select*&quot; read-only=&quot;true&quot; /&gt;    &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot; /&gt;    &lt;tx:method name=&quot;is*&quot; read-only=&quot;true&quot; /&gt;    &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot; /&gt;    &lt;tx:method name=&quot;fill*&quot; read-only=&quot;true&quot; /&gt;    &lt;tx:method name=&quot;count*&quot; read-only=&quot;true&quot; /&gt;    &lt;tx:method name=&quot;add*&quot; /&gt;    &lt;tx:method name=&quot;insert*&quot; /&gt;    &lt;tx:method name=&quot;save*&quot; /&gt;    &lt;tx:method name=&quot;update*&quot;/&gt;    &lt;tx:method name=&quot;change*&quot; /&gt;    &lt;tx:method name=&quot;delete*&quot; /&gt;    &lt;tx:method name=&quot;remove*&quot; /&gt;    &lt;tx:method name=&quot;clean*&quot; /&gt;    &lt;tx:method name=&quot;active*&quot; /&gt;    &lt;tx:method name=&quot;deactive*&quot; /&gt;    &lt;tx:method name=&quot;enable*&quot;/&gt;    &lt;tx:method name=&quot;disable*&quot; /&gt;    &lt;tx:method name=&quot;accept*&quot; /&gt;    &lt;!--其他方法使用默认事务策略 propagation=&quot;NEVER&quot; --&gt;    &lt;tx:method name=&quot;*&quot;  propagation=&quot;NEVER&quot;/&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;\n¶扩展Spring的AbstractRoutingDataSource抽象类（该类充当了DataSource的路由中介, 能有在运行时, 根据某种key值来动态切换到真正的DataSource上。）\n查看源码，AbstractRoutingDataSource的声明\npublic abstract class AbstractRoutingDataSource extends AbstractDataSource implements InitializingBean\n它继承了AbstractDataSource，而AbstractDataSource是javax.sql.DataSource的子类，分析它的getConnection方法\npublic Connection getConnection() throws SQLException &#123;    return determineTargetDataSource().getConnection();  &#125;public Connection getConnection(String username, String password) throws SQLException &#123;      return determineTargetDataSource().getConnection(username, password);  &#125;\n再查看determineTargetDataSource()方法\nprotected DataSource determineTargetDataSource() &#123;    Assert.notNull(this.resolvedDataSources, &quot;DataSource router not initialized&quot;);      Object lookupKey = determineCurrentLookupKey();    DataSource dataSource = this.resolvedDataSources.get(lookupKey);    if (dataSource == null &amp;&amp; (this.lenientFallback || lookupKey == null)) &#123;        dataSource = this.resolvedDefaultDataSource;    &#125;    if (dataSource == null) &#123;        throw new IllegalStateException(&quot;Cannot determine target DataSource for lookup key [&quot; + lookupKey + &quot;]&quot;);    &#125;    return dataSource;&#125;\n这里的重点是determineCurrentLookupKey()方法，这是AbstractRoutingDataSource类中的一个抽象方法，而它的返回值是你所要用的数据源dataSource的key值，有了这个key值，resolvedDataSource（这是个map,由配置文件中设置好后存入的）就从中取出对应的DataSource，如果找不到，就用配置默认的数据源\n没错，要扩展AbstractRoutingDataSource类，并重写其中的determineCurrentLookupKey()方法，来实现数据源的切换\npublic class ReadWriteSplitRoutingDataSource extends AbstractRoutingDataSource &#123;    @Override    protected Object determineCurrentLookupKey() &#123;        return DbContextHolder.getDbType();    &#125;&#125;\nDbContextHolder是我们封装的对数据源进行操作的类\npublic class DbContextHolder &#123;    public enum DbType &#123;        MASTER,        SLAVE    &#125;    private static final ThreadLocal&lt;DbType&gt; contextHolder = new ThreadLocal&lt;DbType&gt;();    public static void setDbType(DbType dbType) &#123;        if(dbType == null)&#123;            throw new NullPointerException();        &#125;        contextHolder.set(dbType);    &#125;    public static DbType getDbType() &#123;        return contextHolder.get() == null ? DbType.MASTER : contextHolder.get();    &#125;    public static void clearDbType() &#123;        contextHolder.remove();    &#125;&#125;\n这里的setDbType()什么时候执行呢？当然是在需要切换数据源的时候执行，应用面向切面，增加一个注解标签，在service层中需要切换数据源的方法上，写上注解标签，调用相应方法切换数据源，这里的@ReadOnlyConnection将在service层中切换到读库\n@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ReadOnlyConnection &#123;&#125;\n增加@Aspect的一个切面拦截类，切换数据源\n@Aspect@Componentpublic class ReadOnlyConnectionInterceptor implements Ordered &#123;    private static final Logger logger = LoggerFactory.getLogger(ReadOnlyConnectionInterceptor.class);    @Around(&quot;@annotation(readOnlyConnection)&quot;)    public Object proceed(ProceedingJoinPoint proceedingJoinPoint, ReadOnlyConnection readOnlyConnection) throws Throwable &#123;        try &#123;            logger.info(&quot;set database connection to read only&quot;);            DbContextHolder.setDbType(DbContextHolder.DbType.SLAVE);            Object result = proceedingJoinPoint.proceed();            return result;        &#125; finally &#123;            DbContextHolder.clearDbType();            logger.info(&quot;restore database connection&quot;);        &#125;    &#125;    @Override    public int getOrder() &#123;        return 0;    &#125;&#125;\n¶数据源加载与事务控制\n还记得上面那个由SpringBoot自动加载相关属性的application.properties么\nSpringBoot会自动根据application.properties将数据源属性前缀是spring.datasource配置单数据源，并且初始化相应的SqlSessionFactory(数据库session的连接工厂)与TransactionManager(事务管理器)\n这句话是重点，念三遍\n所以，在多数据源的需求下，必须要我们手动初始化相应的bean\n@Configuration@EnableAutoConfiguration@MapperScan(basePackages = &quot;cn.abc.lele.*.mapper&quot;, sqlSessionFactoryRef = &quot;sqlSessionFactory&quot;)public class DatabaseConfiguration &#123;    @Autowired    private ApplicationContext appContext;    //初始化主库    @Bean(name = &quot;masterDataSource&quot;)    @ConfigurationProperties(prefix = &quot;master.datasource&quot;)    @Primary    public DataSource masterDataSource() &#123;        return DataSourceBuilder.create().build();    &#125;    //初始化从库    @Bean(name = &quot;slaveDataSource&quot;)    @ConfigurationProperties(prefix = &quot;slave.datasource&quot;)    public DataSource slaveDataSource() &#123;        return DataSourceBuilder.create().build();    &#125;    //初始化数据源bean，这个bean很重要，后面事务控制也会用到    @Bean    public AbstractRoutingDataSource roundRobinDataSouceProxy(@Qualifier(&quot;masterDataSource&quot;)DataSource master,  @Qualifier(&quot;slaveDataSource&quot;) DataSource slave) &#123;        ReadWriteSplitRoutingDataSource proxy = new ReadWriteSplitRoutingDataSource();        Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;Object, Object&gt;();        targetDataSources.put(DbContextHolder.DbType.MASTER, master);        targetDataSources.put(DbContextHolder.DbType.SLAVE,  slave);        proxy.setDefaultTargetDataSource(master);        proxy.setTargetDataSources(targetDataSources);        return proxy;    &#125;    //初始化SqlSessionFactory，将自定义的多数据源ReadWriteSplitRoutingDataSource类实例注入到工厂中    @Bean    public SqlSessionFactory sqlSessionFactory(@Qualifier(&quot;masterDataSource&quot;)DataSource master, @Qualifier(&quot;slaveDataSource&quot;) DataSource slave) throws Exception &#123;        final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();               sessionFactory.setDataSource((DataSource)appContext.getBean(&quot;roundRobinDataSouceProxy&quot;));        return sessionFactory.getObject();    &#125;&#125;\n到这里，启动工程，多数据源切换能正常执行，但是你会发现事务失效，这是为什么呢？\n我们初始化了两个数据源，并且注入给SqlSessionFactory，所以对两个数据源切换并各自访问完全没有问题，让我们回顾一下上面的说过SpringBoot的一个作用：\nSpringBoot会自动根据application.properties将数据源属性前缀是spring.datasource配置单数据源，并且初始化相应的SqlSessionFactory(数据库session的连接工厂)与TransactionManager(事务管理器)\n所以，这里SpringBoot即使找到数据源属性前缀spring.datasource的数据源配置，也只是单数据源，这就是为什么多数据源切换正常执行，而事务失效的原因！\n因为TransactionManager事务管理器里的dataSource根本不是我们的masterDataSource和slaveDataSource(我觉得应该是null，待验证\n所以，必须手动初始化一个多数据源的TransactionManager，并且指定bean的名称与上面的transaction.xml中的transaction-manager=&quot;transactionManager&quot;一致！这样，Spring将会使用我们初始化之后的TransactionManager。\n新增一个MyDataSourceTransactionManagerAutoConfiguration事务管理器，继承SpringBoot的jar包中DataSourceTransactionManagerAutoConfiguration自动配置数据源事务管理器类，并且构造注入我们初始化的数据源ReadWriteSplitRoutingDataSource的实例\n@Configuration@EnableTransactionManagementpublic class MyDataSourceTransactionManagerAutoConfiguration extends DataSourceTransactionManagerAutoConfiguration &#123;    @Autowired    private ApplicationContext appContext;    /**     * 自定义事务     * MyBatis自动参与到spring事务管理中，无需额外配置，只要org.mybatis.spring.SqlSessionFactoryBean引用的数据源与DataSourceTransactionManager引用的数据源一致即可，否则事务管理会不起作用。     * @return     */    @Bean(name = &quot;transactionManager&quot;)    public DataSourceTransactionManager transactionManagers() &#123;        return new DataSourceTransactionManager((DataSource)appContext.getBean(&quot;roundRobinDataSouceProxy&quot;));    &#125;&#125;\n重新启动工程，事务测试通过。\n","tags":["Spring Boot","事务"]},{"title":"Dubbox快速指南","url":"/2017/03/07/dubbox%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97/","content":"该demo的github地址：dubbox-demo\n准备\n¶依赖\n建议在maven安装目录下的conf\\settings.xml的&lt;mirrors&gt;标签中添加如下镜像，以提高maven打包速度\n&lt;mirror&gt;    &lt;id&gt;alimaven&lt;/id&gt;    &lt;name&gt;aliyun maven&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt;\n下载dubbox源码并且编译：\n\ngit clone git@github.com:dangdangdotcom/dubbox.git\n执行maven命令mvn clean install -Dmaven.test.skip\n\n¶注册中心\n推荐使用Zookeeper注册中心\nzookeeper安装\nZookeeper是Apacahe Hadoop的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbo服务的注册中心，工业强度较高，可用于生产环境，并推荐使用，参见：Apache ZooKeeper\n¶接口定义与通用实体\ncommon工程只定义了服务提供者与消费者所依赖的接口与实体类\n该工程下的接口与实体在服务提供方和消费方共享\n¶配置管理\nconfig工程只负责管理dubbo通用配置，在服务提供方和消费方共享，除此之外也可配置如数据库、缓存、队列等等\n快速启动\n¶属性配置\n执行初始化init.sql\n该demo基于springboot，以properties方式配置公共部分，xml配置各个服务不同之处\nconfig工程引入依赖所需的jar\napplication.properties中加入注册中心配置：\ndubbo.registry.address=@dubbo.registry.address@\n具体值请修改pom不同环境打包的profile标签指定\nconfig工程另外配置数据库，缓存等等，这里不再赘述\n¶服务提供者\n引入common与config\n新建dubbo-config.xml,更多配置详情请参考dubbo配置参考手册\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd    http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;    &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;    &lt;dubbo:application name=&quot;base-user-service&quot; /&gt;    &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;    &lt;dubbo:registry address=&quot;$&#123;dubbo.registry.address&#125;&quot; file=&quot;c:/dubbo/base-user-service.cache&quot;/&gt;    &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;        &lt;!-- 通过注册中心发现监控中心服务 --&gt;    &lt;dubbo:monitor protocol=&quot;registry&quot; /&gt;        &lt;!-- 扫描注解包路径，多个包用逗号分隔，不填pacakge表示扫描当前ApplicationContext中所有的类 --&gt;    &lt;dubbo:annotation package=&quot;cn.zylele.base&quot; /&gt;        &lt;!-- 服务提供者缺省值配置 --&gt;    &lt;dubbo:provider timeout=&quot;60000&quot; delay=&quot;-1&quot; retries=&quot;0&quot; /&gt;    &lt;/beans&gt;\n服务提供者实现服务接口，这里的@Service的注解是dubbo的服务提供方注解，声明需要暴露的服务接口，并指定实现\n注：服务既可以是提供者也可以是消费者，下面的DynamicQueryService为另一个服务。\n@Reference是dubbo的服务消费方注解，生成远程服务代理，来引用别的服务\n@Component@Servicepublic class UserQueryServiceImpl implements UserQueryService&#123;    @Reference(check = false)    DynamicQueryService dynamicQueryService;        @Autowired    UserMapper userMapper;        @Override    public User getUser(String userid) &#123;        return userMapper.getUser(userid);    &#125;&#125;\n启动入口，发布服务\nimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.ImportResource;@Configuration@ImportResource(value = &quot;classpath:*.xml&quot;)@SpringBootApplicationpublic class UserServiceProvider &#123;        public static void main(String[] args) throws InterruptedException &#123;        SpringApplication app = new SpringApplication(UserServiceProvider.class);        app.setWebEnvironment(false);        app.run(args);    &#125;&#125;\n¶服务消费者\n引入common\napplication.properties中加入注册中心配置：\ndubbo.registry.address=@dubbo.registry.address@\n具体值请修改pom不同环境打包的profile标签指定\n新建dubbo-config.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd    http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;    &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;    &lt;dubbo:application name=&quot;base-consumer&quot; /&gt;    &lt;!-- 使用zookeeper注册中心暴露发现服务地址 --&gt;    &lt;dubbo:registry address=&quot;$&#123;dubbo.registry.address&#125;&quot; file=&quot;c:/dubbo/base-consumer.cache&quot;/&gt;    &lt;!-- 通过注册中心发现监控中心服务 --&gt;    &lt;dubbo:monitor protocol=&quot;registry&quot; /&gt;        &lt;!-- 扫描注解包路径，多个包用逗号分隔，不填pacakge表示扫描当前ApplicationContext中所有的类 --&gt;    &lt;dubbo:annotation package=&quot;cn.zylele.base&quot; /&gt;        &lt;!-- 关闭所有服务的启动时检查 check=false，总是会返回引用，当服务恢复时，能自动连上--&gt;    &lt;dubbo:consumer check=&quot;false&quot; /&gt;&lt;/beans&gt;\n发现并调用远程服务\n@RestControllerpublic class UserController &#123;    @Reference    UserQueryService userQueryService;        @RequestMapping(value=&quot;/user/get/&#123;userid&#125;&quot;,method=RequestMethod.GET,         produces = MediaType.APPLICATION_JSON_VALUE)    public User readUserInfo(@PathVariable(&quot;userid&quot;) String userid)&#123;        return userQueryService.getUser(userid);    &#125;&#125;\n启动工程，调试\nimport org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.ImportResource;@Configuration@ImportResource(value = &quot;classpath:dubbo-config.xml&quot;)@SpringBootApplicationpublic class BaseConsumer implements EmbeddedServletContainerCustomizer&#123;    public static void main(String[] args) &#123;        SpringApplication.run(BaseConsumer.class, args);    &#125;    public void customize(ConfigurableEmbeddedServletContainer container) &#123;        container.setPort(1000);    &#125;&#125;\n\ndubbox还具有相当多的配置功能，如负载均衡、集群容错，多协议、多注册中心等\n更多示例与参考手册，可查看dubbo用户指南\n","tags":["Dubbox"]},{"title":"开源dubbokeeper MySQL快速启动版","url":"/2017/04/01/%E4%BA%8C%E6%AC%A1%E5%BC%80%E6%BA%90dubbokeeper%20MySQL%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E7%89%88/","content":"github地址：dubbokeeper-mqs\n¶dubbokeeper-mqs是什么\ndubbokeeper-mqs是基于Spring mvc开发的社区版dubboadmin集成服务管理以及服务监控一体的DUBBO服务管理系统，自dubbokeeper基础上整合而成的MySQL快速启动版，并新增服务预警接口、权限登录功能\ndubbokeeper-mqs集成监控与展示，节省服务器资源，提供一键编译部署\n\n¶dubbokeeper-mqs包含哪些功能\n\n应用管理\n动态配置\n统计信息\nDubbo服务监控\nzookeeper信息查看\n服务预警\n\n\n执行数据库初始化脚本application.sql，数据库名可以自定义一个，编码采用utf-8\n¶服务预警\n注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者\n修改com.dubboclub.dk.alarm.impl.AlarmServiceImpl的void alarmHandle(URL url)的实现即可(服务提供者全部宕掉后，将会触发该方法)，通过url.getServiceInterface()获取服务名，发送邮件、发送短信等\n¶部署\n只需配置src/main/resources/dubbo.properties与pom.xml的各属性值\n打包部署到Tomcat启动\n\n\n动态配置\n\n依赖关系\n\n统计信息\n","tags":["Dubbo"]},{"title":"关于Spring Boot与Dubbo REST","url":"/2017/07/08/%E5%85%B3%E4%BA%8ESpring%20Boot%E4%B8%8EDubbo%20REST/","content":"¶关于Spring Boot\nSpring Boot的设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域成为领导者。\n\nSpring Boot(英文中是“引导”的意思)，是用来简化Spring应用的搭建到开发的过程。应用开箱即用，只要通过 “just run”（可能是 java -jar 或 tomcat 或 maven插件run 或 shell脚本），就可以启动项目。二者，Spring Boot 只要很少的Spring配置文件（例如那些xml，property）。\n因为“习惯优先于配置”的原则，使得Spring Boot在快速开发应用和微服务架构实践中得到广泛应用。\n¶Spring Boot整合Dubbo实现SOA\nSpring Boot对于作为微服务的框架来说\n优点：\n\n嵌入式Tomcat、Jetty容器，无需部署war包\n遵循&quot;习惯优于配置&quot;原则，只需很少的配置，大部分时候可以使用默认配置\n项目快速搭建\n丰富的和第三方框架无配置整合的jar包\n\n缺点：\n\n坑有些多, 文档略少\n简单的背后蕴藏了较大的学习曲线\n\nDubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，是阿里巴巴SOA服务化治理方案的核心框架，有以下几个特性\n\n远程通信，向本地调用一样调用远程方法。\n集群容错\n服务自动发现和注册，可平滑添加或者删除服务提供者。\n\n一般而言，我们常常暴露HTTP服务，并走JSON模式。但慢慢量大了，缺少一种SOA的治理方案。之后整合Dubbo服务治理方案实现SOA，这样可以暴露出Dubbo服务接口，提供给Dubbo消费者进行RPC调用。\n可以看出，Dubbo才是应用服务化绝对的核心，在这过程中，Spring Boot扮演为Dubbo提供服务启动初始化入口，整合各种第三方框架，为Dubbo服务提供各组件支持的角色\n所以，Spring Boot在已经部署Dubbo服务的情况下，只作为容器来说没有必要使用\n\n¶Dubbo服务的开放\n¶概述与应用场景\n以REST为例\nDubbo支持多种远程调用方式，基于简单的文本格式消息和通用的HTTP协议，使它具备极广的适用性，几乎所有语言和平台都对它提供支持，同时其学习和使用的门槛也较低。\n在dubbo中支持REST，可以为当今多数主流的远程调用场景都带来（显著）好处：\n\n显著简化企业内部的异构系统之间的（跨语言）调用。此处主要针对这种场景：dubbo的系统做服务提供端，其他语言的系统（也包括某些不基于dubbo的java系统）做服务消费端，两者通过HTTP和文本消息进行通信。即使相比Thrift、ProtoBuf等二进制跨语言调用方案，REST也有自己独特的优势（详见后面讨论）\n\n\n显著简化对外Open API（开放平台）的开发。既可以用dubbo来开发专门的Open API应用，也可以将原内部使用的dubbo service直接“透明”发布为对外的Open REST API（当然dubbo本身未来最好可以较透明的提供诸如权限控制、频次控制、计费等诸多功能）\n\n\n显著简化手机（平板）APP或者PC桌面客户端开发。类似于2，既可以用dubbo来开发专门针对无线或者桌面的服务器端，也可以将原内部使用的dubbo service直接”透明“的暴露给手机APP或桌面程序。当然在有些项目中，手机或桌面程序也可以直接访问以上场景2中所述的Open API。\n\n\n显著简化浏览器AJAX应用的开发。类似于2，既可以用dubbo来开发专门的AJAX服务器端，也可以将原内部使用的dubbo service直接”透明“的暴露给浏览器中JavaScript。当然，很多AJAX应用更适合与web框架协同工作，所以直接访问dubbo service在很多web项目中未必是一种非常优雅的架构。\n\n\n为企业内部的dubbo系统之间（即服务提供端和消费端都是基于dubbo的系统）提供一种基于文本的、易读的远程调用方式。\n\n\n一定程度简化dubbo系统对其它异构系统的调用。可以用类似dubbo的简便方式“透明”的调用非dubbo系统提供的REST服务（不管服务提供端是在企业内部还是外部）\n\n\n需要指出的是，我认为1～3是dubbo的REST调用最有价值的三种应用场景，并且我们为dubbo添加REST调用，其最主要到目的也是面向服务的提供端，即开发REST服务来提供给非dubbo的（异构）消费端。\n\n¶一些问题\nDubbo REST的服务能和Dubbo注册中心、监控中心集成吗？\n\n可以的，而且是自动集成的，也就是你在dubbo中开发的所有REST服务都会自动注册到服务册中心和监控中心，可以通过它们做管理。\n\n\n但是，只有当REST的消费端也是基于dubbo的时候，注册中心中的许多服务治理操作才能完全起作用。而如果消费端是非dubbo的，自然不受注册中心管理，所以其中很多操作是不会对消费端起作用的。\n\nDubbo REST中如何实现负载均衡和容错（failover）？\n\n如果dubbo REST的消费端也是dubbo的，则Dubbo REST和其他dubbo远程调用协议基本完全一样，由dubbo框架透明的在消费端做load balance、failover等等。\n\n\n如果dubbo REST的消费端是非dubbo的，甚至是非java的，则最好配置服务提供端的软负载均衡机制，目前可考虑用LVS、HAProxy、 Nginx等等对HTTP请求做负载均衡。\n\n","tags":["Spring Boot","Dubbo"]},{"title":"关于这个博客","url":"/2015/01/12/%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2/","content":"好多事情都要自己去做的时候才知道会碰到很多问题。\n纸上得来终觉浅，\n绝知此事要躬行。\n以下都是免费开源的，任何人都可以使用和修改。\n不同于wordpress，hexo由于需要使用Github，Git，Markdown，Node，js这样的工具，好多插件、widget都需要自己安装、设置。点击这个HEXO+Github,搭建属于自己的博客或许会帮助到你。感谢issnan的NexT主题。\n\nGitHub是全球最大的开源代码托管网站，Github很好的将代码和社区联系在了一起，于是发生了很多有趣的事情，世界也因为他美好了一点点。Github作为现在最流行的代码仓库，已经得到很多大公司和项目的青睐，比如jQuery、Twitter等。\nGithub提供了Github Pages的服务，不仅可以方便的为项目建立介绍站点，允许用户自定义项目首页，用来替代默认的源码列表。也可以用来建立个人博客。\n所以，GitHub Pages可以被认为是用户编写的、托管在GitHub上的静态网页。\nhexo是一个基于Node.js的静态博客程序，可以方便的生成静态网页托管在GitHub和Heroku上。配合git版本控制系统，能方便提交内容更新到本地仓库，并远程部署到GitHub Pages上。\n以上\n","tags":["GitHub","Hexo"]},{"title":"浅谈依赖注入--Dependency Injection","url":"/2015/05/16/%E6%B5%85%E8%B0%88%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5--Dependency%20Injection/","content":"¶概述\nSpring能有效地组织J2EE应用各层的对象。不管是控制层的Action对象，还是业务层的Service对象，还是持久层的DAO对象，都可在Spring的 管理下有机地协调、运行。Spring将各层的对象以松耦合的方式组织在一起，Action对象无须关心Service对象的具体实现，Service对 象无须关心持久层对象的具体实现，各层对象的调用完全面向接口。当系统需要重构时，代码的改写量将大大减少。\n\n上面所说的一切都得宜于Spring的核心机制，依赖注入。\n\n依赖注入让bean与bean之间以配置文件组织在一起，而不是以硬编码的方式耦合在一起。\n\n依赖注入(Dependency Injection)和控制反转(Inversion of Control)是同一个概念。具体含义是:\n\n当某个角色(可能是一个Java实例，调用者)需要另一个角色(另一个Java实例，被调用者)的协助时，在传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在Spring里，创建被调用者的工作不再由调用者来完成，因此称为控制反转;创建被调用者实例的工作通常由Spring容器来完成，然后注入调用者，因此也称为依赖注入。\n\n不管是依赖注入，还是控制反转，都说明Spring采用动态、灵活的方式来管理各种对象。对象与对象之间的具体实现互相透明。在理解依赖注入之前，看如下这个问题在各种社会形态里如何解决:\n一个人(Java实例，调用者)需要一把斧子(Java实例，被调用者)\n\n\n原始社会里，几乎没有社会分工。需要斧子的人(调用者)只能自己去磨一把斧子(被调用者)。对应的情形为:Java程序里的调用者自己创建被调用者。\n\n\n进入工业社会，工厂出现。斧子不再由普通人完成，而在工厂里被生产出来，此时需要斧子的人(调用者)找到工厂，购买斧子，无须关心斧子的制造过程。对应Java程序的简单工厂的设计模式。\n\n\n进入“按需分配”社会，需要斧子的人不需要找到工厂，坐在家里发出一个简单指令:需要斧子。斧子就自然出现在他面前。对应Spring的依赖注入。\n\n\n第一种情况下，Java实例的调用者创建被调用的Java实例，必然要求被调用的Java类出现在调用者的代码里。无法实现二者之间的松耦合。\n第二种情况下，调用者无须关心被调用者具体实现过程，只需要找到符合某种标准(接口)的实例，即可使用。此时调用的代码面向接口编程，可以让调用者和被调用者解耦，这也是工厂模式大量使用的原因。但调用者需要自己定位工厂，调用者与特定工厂耦合在一起。\n第三种情况下，调用者无须自己定位工厂，程序运行到需要被调用者时，系统自动提供被调用者实例。事实上，调用者和被调用者都处于Spring的管理下，二者之间的依赖关系由Spring提供。\n\n¶依赖注入方式\n所谓依赖注入，是指程序运行过程中，如果需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部的注入。Spring的依赖注入对调用者和被调用者几乎没有任何要求，完全支持对POJO之间依赖关系的管理。依赖注入通常有两种:\n\n\n设值注入。\n\n\n构造注入。\n\n\n¶设值注入\n设值注入是指通过setter方法传入被调用者的实例。这种注入方式简单、直观，因而在Spring的依赖注入里大量使用。看下面代码，是Person的接口\n//定义Person接口public interface Person&#123;    //Person接口里定义一个使用斧子的方法    public void useAxe();&#125;\n然后是Axe的接口\n//定义Axe接口public interface Axe&#123;    //Axe接口里有个砍的方法    public void chop();&#125;\nPerson的实现类\n//Chinese实现Person接口public class Chinese implements Person&#123;    //面向Axe接口编程，而不是具体的实现类    private Axe axe;    //默认的构造器    public Chinese()&#123;&#125;    //设值注入所需的setter方法    public void setAxe(Axe axe)&#123;        this.axe = axe;    &#125;    //实现Person接口的useAxe方法    public void useAxe()&#123;        System.out.println(axe.chop());    &#125;&#125;\nAxe的第一个实现类\n//Axe的第一个实现类 StoneAxepublic class StoneAxe implements Axe&#123;    //默认构造器    public StoneAxe()&#123;&#125;    //实现Axe接口的chop方法    public String chop()&#123;        return &quot;石斧砍柴好慢&quot;;    &#125;&#125;\n下面采用Spring的配置文件将Person实例和Axe实例组织在一起。配置文件如下所示:\n&lt;!-- Spring配置文件的根元素 --&gt;&lt;BEANS&gt;&lt;!—定义第一bean，该bean的id是chinese, class指定该bean实例的实现类 --&gt;&lt;BEAN class=lee.Chinese id=chinese&gt;&lt;!-- property元素用来指定需要容器注入的属性，axe属性需要容器注入此处是设值注入，因此Chinese类必须拥有setAxe方法 --&gt;&lt;property name=&quot;axe&quot;&gt;&lt;!-- 此处将另一个bean的引用注入给chinese bean --&gt;&lt;REF local=&quot;”stoneAxe”/&quot;&gt;&lt;/property&gt;&lt;/BEAN&gt;&lt;!-- 定义stoneAxe bean --&gt;&lt;BEAN class=lee.StoneAxe id=stoneAxe /&gt;&lt;/BEANS&gt;\n从配置文件中，可以看到Spring管理bean的灵巧性。bean与bean之间的依赖关系放在配置文件里组织，而不是写在代码里。通过配置文件的 指定，Spring能精确地为每个bean注入属性。因此，配置文件里的bean的class元素，不能仅仅是接口，而必须是真正的实现类。\nSpring会自动接管每个bean定义里的property元素定义。Spring会在执行无参数的构造器后、创建默认的bean实例后，调用对应 的setter方法为程序注入属性值。property定义的属性值将不再由该bean来主动创建、管理，而改为被动接收Spring的注入。\n每个bean的id属性是该bean的惟一标识，程序通过id属性访问bean，bean与bean的依赖关系也通过id属性完成。\n下面看主程序部分:\npublic class BeanTest&#123;    public static void main(String[] args)throws Exception&#123;        //因为是独立的应用程序，显式地实例化Spring的上下文。        ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;bean.xml&quot;);        //通过Person bean的id来获取bean实例，面向接口编程，因此此处强制类型转换为接口类型        Person p = (Person)ctx.getBean(&quot;chinese&quot;);        //直接执行Person的userAxe()方法。        p.useAxe();    &#125;&#125;\n程序的执行结果如下:\n石斧砍柴好慢\n主程序调用Person的useAxe()方法时，该方法的方法体内需要使用Axe的实例，但程序里没有任何地方将特定的Person实例和Axe实例耦合在一起。或者说，程序里没有为Person实例传入Axe的实例，Axe实例由Spring在运行期间动态注入。\nPerson实例不仅不需要了解Axe实例的具体实现，甚至无须了解Axe的创建过程。程序在运行到需要Axe实例的时候，Spring创建了Axe 实例，然后注入给需要Axe实例的调用者。Person实例运行到需要Axe实例的地方，自然就产生了Axe实例，用来供Person实例使用。\n调用者不仅无须关心被调用者的实现过程，连工厂定位都可以省略(真的是按需分配啊!)。\n如果需要改写Axe的实现类。或者说，提供另一个实现类给Person实例使用。Person接口、Chinese类都无须改变。只需提供另一个Axe的实现，然后对配置文件进行简单的修改即可。\nAxe的另一个实现如下:\n//Axe的另一个实现类 SteelAxepublic class SteelAxe implements Axe&#123;    //默认构造器    public SteelAxe()&#123;&#125;    //实现Axe接口的chop方法    public String chop()&#123;        return &quot;钢斧砍柴真快&quot;;    &#125;&#125;\n然后，修改原来的Spring配置文件，在其中增加如下一行:\n&lt;!-- 定义一个steelAxe bean--&gt;&lt;BEAN class=lee.SteelAxe id=steelAxe /&gt;\n该行重新定义了一个Axe的实现:SteelAxe。然后修改chinese bean的配置，将原来传入stoneAxe的地方改为传入steelAxe。也就是将\n&lt;REF local=&quot;”stoneAxe”/&quot;&gt;\n改成\n&lt;REF local=&quot;”steelAxe”/&quot;&gt;\n此时再次执行程序，将得到如下结果:\n钢斧砍柴真快\nPerson与Axe之间没有任何代码耦合关系，bean与bean之间的依赖关系由Spring管理。采用setter方法为目标bean注入属性的方式，称为设值注入。\n业务对象的更换变得相当简单，对象与对象之间的依赖关系从代码里分离出来，通过配置文件动态管理。\n¶构造注入\n所谓构造注入，指通过构造函数来完成依赖关系的设定，而不是通过setter方法。对前面代码Chinese类做简单的修改，修改后的代码如下:\n//Chinese实现Person接口public class Chinese implements Person&#123;    //面向Axe接口编程，而不是具体的实现类    private Axe axe;    //默认的构造器    public Chinese()&#123;&#125;    //构造注入所需的带参数的构造器    public Chinse(Axe axe)&#123;        this.axe = axe;    &#125;    //实现Person接口的useAxe方法    public void useAxe()&#123;        System.out.println(axe.chop());    &#125;&#125;\n此时无须Chinese类里的setAxe方法，构造Person实例时，Spring为Person实例注入所依赖的Axe实例。构造注入的配置文件也需做简单的修改，修改后的配置文件如下:\n&lt;!-- Spring配置文件的根元素 --&gt;&lt;BEANS&gt;&lt;!—定义第一个bean，该bean的id是chinese, class指定该bean实例的实现类 --&gt;&lt;BEAN class=lee.Chinese id=chinese&gt;&lt;/BEAN&gt;&lt;!-- 定义stoneAxe bean --&gt;&lt;BEAN class=lee.SteelAxe id=steelAxe /&gt;&lt;/BEANS&gt;\n执行效果与使用steelAxe设值注入时的执行效果完全一样。区别在于:创建Person实例中Axe属性的时机不同——设值注入是现创建一个默认的bean实例，然后调用对应的构造方法注入依赖关系。而构造注入则在创建bean实例时，已经完成了依赖关系的。\n","tags":["Spring","依赖注入"]},{"title":"用Travis CI自动部署GitHub项目","url":"/2017/09/10/%E7%94%A8Travis%20CI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2GitHub%E9%A1%B9%E7%9B%AE/","content":"介绍一套免费持续集成构建部署解决方案。\n\n本文以部署基于Node.js的静态博客框架hexo为例\n源码地址：zylele/blog\n\n¶Travis CI\n顾名思义，Travis CI是一个持续集成(Continuous integration，简称CI)的工具。它可以在公共的Github仓库上免费使用。\n\nTravis CI 是目前新兴的开源持续集成构建项目，它与jenkins，GO的很明显的特别在于采用yaml格式，简洁清新独树一帜。目前大多数的github项目都已经移入到Travis CI的构建队列中，据说Travis CI每天运行超过4000次完整构建。\n\n¶构建\n¶在Github建立代码库\n首先，要在Github上建立一个代码仓库，要将自己hexo博客push到上面。hexo项目作为运行部署的项目，然后Github Page的项目作为部署的目标项目。\n¶开启Travis CI\n第二步，我们需要有一个Travis CI的账号，直接进入Travis CI官网，用自己的Github账号授权登录即可。\n然后可以看到当前账号的所有代码仓库，接下来将博客项目的状态设置为启用。\n\n¶创建SSH key\n如果你的github已经配置过SSH了，可以省略这一步，或者你想缩小权限控制粒度，可继续执行这一步骤。\n第三步，创建一个部署在Travis CI上面的SSH key利用这个SSH key可以让Travis CI向我们自己的项目提交代码。\n$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;\n得到id_rsa.pub和id_rsa，然后将有pub后缀的配置到Deploy key。\n\n记得要将Allow write access的选项选上，这样Travis CI才能获得push代码的权限。\n¶加密私钥\n刚才讲公钥文件配置好了，然后就要配置私钥文件，在hexo项目下面建立一个.travis的文件夹来放置需要配置的文件。\n首先要安装travis命令行工具(如果在国内的网络环境下建议安装之前先换源)。\n$ gem install travis\n用命令行工具登录：\n$ travis login --auto\n然后将刚刚生成的id_rsa复制到.travis文件夹，用命令行工具进行加密：\n$ travis encrypt-file id_rsa --add\n这个时候会生成加密之后的秘钥文件id_rsa.enc，原来的文件id_rsa就可以删掉了。\n这时可以看到终端输出了一段\nopenssl aes-256-cbc -K $encrypted_xxxxxxxxxxx_key -iv $encrypted_xxxxxxxxxxx_iv\n这样格式的信息，这是travis用来解密id_rsa.enc的key，先保存起来，后面配置.travis.yml会用到它。\n为了让git默认连接SSH还要创建一个ssh_config文件。在.travis文件夹下创建一个ssh_config文件，输入以下内容：\nHost github.com    User git    StrictHostKeyChecking no    IdentityFile ~/.ssh/id_rsa    IdentitiesOnly yes\n现在进入travis CI设置页面\n\n可以看到刚刚travis命令行生成的解密key\n\n顺便把上面的开关打开\n\n这样，当向项目push代码的时候travis CI就会根据.travis.yml的内容去部署我们的项目了。\n¶.travis.yml\n最后就要配置.travis.yml。在项目的根目录创建.travis.yml文件。\n# 配置语言及相应版本language: node_jssudo: falsenode_js: stable# 项目所在分支branches:  only:  - master# node_modules 缓存cache:  directories:  - node_modules# 配置环境before_install:# 替换为刚才生成的解密信息- openssl aes-256-cbc -K $encrypted_xxxxxxxxx_key -iv $encrypted_xxxxxxxxx_iv -in .travis/id_rsa.enc -out ~/.ssh/id_rsa -d# 改变文件权限- chmod 600 ~/.ssh/id_rsa# 配置 ssh- eval $(ssh-agent)- ssh-add ~/.ssh/id_rsa- cp .travis/ssh_config ~/.ssh/config# 配置 git 替换为自己的信息- git config --global user.name &#x27;zylele&#x27;- git config --global user.email 657345933@qq.com# 安装依赖install:- npm install# 部署的命令script:- hexo clean- hexo g -d\n好了现在只要向项目push代码就可以触发部署了，进入https://travis-ci.org就可以看到部署的过程了。\n¶后记\n在部署了一遍之后发现，运行npm install安装node的库时候占据了部署的很大一部分时间，这里有一个技巧，可以将node_modules缓存起来，这样可以节省部署的时间。\n# node_modules 缓存cache:  directories:  - node_modules\n¶最后\n.travis.yml的完整代码可以看我的.travis.yml文件。博客的完整代码可以看这里。\n","tags":["持续集成"]},{"title":"自动构建社交feed到你的主页","url":"/2024/12/03/%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E7%A4%BE%E4%BA%A4feed%E5%88%B0%E4%BD%A0%E7%9A%84%E4%B8%BB%E9%A1%B5/","content":"项目地址：social-readme，欢迎点个star～\nAutomatically build Social feeds in your Profile Readme everyday, preview: github.com/zylele\n自动构建社交feed到你的主页readme中，预览：github.com/zylele\n\n\n或者我的博客，“关于我”页面，预览：「关于」 | 乐章\n\n¶目前支持\n\nrss，符合rss2.0或atom标准，比如 我的博客 rss链接是https://zylele.github.io/atom.xml\n豆瓣（想看、在看和看过的书和电影，想听、在听和听过的音乐）\n\n¶GitHub主页构建使用方式\n¶1.确认存在Profile Repository(&lt;username&gt;/&lt;username&gt;)项目\n\n仓库名与你的GitHub用户名相同的，就是Profile Repository\n这是GitHub的一个彩蛋，仓库根目录的README.md文件将会被渲染展示在你的个人公共主页上\n比如我的Profile Repository是 github.com/zylele/zylele ，README.md将会展示在我的主页上：zylele(Eric)\n\n¶2.修改根目录文件\n根据你的需要，在你的readme中增加以下内容\n博客:\n&lt;!-- START_SECTION:blog --&gt;&lt;!-- END_SECTION:blog --&gt;\n豆瓣:\n&lt;!-- START_SECTION:douban --&gt;&lt;!-- END_SECTION:douban --&gt;\n这些是构建feed信息的识别点\n¶2.配置workflow文件\n\n\n在你项目仓库的根目录，新建.github/workflows/social-readme.yml，或者编辑其他已有的workflow文件\n\n\n拷贝以下代码到上一步的文件中，根据你的需要，选填博客atom链接blog_rss_link，豆瓣用户名douban_name（进入豆瓣个人主页，douban.com/people/username/，这里地址中的username就是用户名）\n\n\n我的GitHub主页参考配置如下：\nname: Social Readmeon:  schedule:    - cron: &#x27;0 0 * * *&#x27;  workflow_dispatch:  push:    branches:      - masterjobs:  update-social:    runs-on: ubuntu-latest    steps:      - uses: zylele/social-readme@master        with:          blog_rss_link: https://zylele.github.io/atom.xml          douban_name: znyalor\n¶非根目录readme文件构建使用方式\n如我的博客的源码仓库，其中 关于我 页面对应的仓库文件是source/about/index.md\n¶1.修改目标文件\n同样的，在目标文件中插入上述的“识别点”\n¶2.配置workflow文件\n同样的，在仓库的工作流文件中增加workflow配置。\n因为是更新非根目录的readme文件，则需要配置file_path参数来指定文件路径\n这里我的配置如下：\nname: Social Readmeon:  schedule:    - cron: &#x27;0 0 * * *&#x27;  workflow_dispatch:  push:    branches:      - masterjobs:  update-social:    runs-on: ubuntu-latest    steps:      - uses: zylele/social-readme@master        with:          douban_name: znyalor          file_path: source/about/index.md\n¶完整配置说明\n如果你想定制更多构建细节，在workflow文件中的with有如下可选参数\n- uses: zylele/social-readme@master  with:    blog_rss_link: # 博客链接    blog_limit: 5 # blog数量    douban_name: # 豆瓣用户名    douban_limit: 5 # 豆瓣最新动态数量    commit_message: Updated social rss by social-readme # commit说明    file_path: # 更新非readme文件，填写仓库中的文件路径，如source/about/index.md\n¶Star History\n\n","tags":["GitHub","持续集成"]}]