<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>乐章</title>
  
  <subtitle>鸡鸣枕上，夜气方回</subtitle>
  <link href="https://zylele.github.io/atom.xml" rel="self"/>
  
  <link href="https://zylele.github.io/"/>
  <updated>2025-11-01T01:16:14.349Z</updated>
  <id>https://zylele.github.io/</id>
  
  <author>
    <name>Eric</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自动构建社交feed到你的主页</title>
    <link href="https://zylele.github.io/2024/12/03/%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E7%A4%BE%E4%BA%A4feed%E5%88%B0%E4%BD%A0%E7%9A%84%E4%B8%BB%E9%A1%B5/"/>
    <id>https://zylele.github.io/2024/12/03/%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E7%A4%BE%E4%BA%A4feed%E5%88%B0%E4%BD%A0%E7%9A%84%E4%B8%BB%E9%A1%B5/</id>
    <published>2024-12-03T23:19:05.000Z</published>
    <updated>2025-11-01T01:16:14.349Z</updated>
    
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/zylele/social-readme">social-readme</a>，欢迎点个star～</p><p>Automatically build Social feeds in your Profile Readme everyday, preview: <a href="https://github.com/zylele" target="_blank">github.com/zylele</a></p><p>自动构建社交feed到你的主页readme中，预览：<a href="https://github.com/zylele" target="_blank">github.com/zylele</a></p><span id="more"></span><p><img src="https://user-images.githubusercontent.com/12383106/233308515-09e00a2a-9277-44a7-ba7b-1e975c50a326.png" alt="image"></p><p>或者我的博客，“关于我”页面，预览：<a href="https://zylele.github.io/about/" target="_blank">「关于」 | 乐章</a></p><p><img src="https://user-images.githubusercontent.com/12383106/233309981-20be571c-92d6-4ff5-b9b1-a7df9049a3ad.png" alt="image"></p><h2 id="目前支持"><a class="header-anchor" href="#目前支持">¶</a>目前支持</h2><ul><li>rss，符合rss2.0或atom标准，比如 <a href="https://zylele.github.io/">我的博客</a> rss链接是<a href="https://zylele.github.io/atom.xml">https://zylele.github.io/atom.xml</a></li><li>豆瓣（想看、在看和看过的书和电影，想听、在听和听过的音乐）</li></ul><h2 id="GitHub主页构建使用方式"><a class="header-anchor" href="#GitHub主页构建使用方式">¶</a>GitHub主页构建使用方式</h2><h3 id="1-确认存在Profile-Repository-username-username-项目"><a class="header-anchor" href="#1-确认存在Profile-Repository-username-username-项目">¶</a>1.确认存在Profile Repository(<code>&lt;username&gt;/&lt;username&gt;</code>)项目</h3><blockquote><p>仓库名与你的GitHub用户名相同的，就是Profile Repository</p><p>这是GitHub的一个彩蛋，仓库根目录的README.md文件将会被渲染展示在你的个人公共主页上</p><p>比如我的Profile Repository是 <a href="https://github.com/zylele/zylele">github.com/zylele/zylele</a> ，README.md将会展示在我的主页上：<a href="https://github.com/zylele">zylele(Eric)</a></p></blockquote><h3 id="2-修改根目录文件"><a class="header-anchor" href="#2-修改根目录文件">¶</a>2.修改根目录文件</h3><p>根据你的需要，在你的readme中增加以下内容</p><p>博客:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- START_SECTION:blog --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- END_SECTION:blog --&gt;</span></span><br></pre></td></tr></table></figure><p>豆瓣:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- START_SECTION:douban --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- END_SECTION:douban --&gt;</span></span><br></pre></td></tr></table></figure><p>这些是构建feed信息的识别点</p><h3 id="2-配置workflow文件"><a class="header-anchor" href="#2-配置workflow文件">¶</a>2.配置workflow文件</h3><ul><li><p>在你项目仓库的根目录，新建<code>.github/workflows/social-readme.yml</code>，或者编辑其他已有的workflow文件</p></li><li><p>拷贝以下代码到上一步的文件中，根据你的需要，选填博客atom链接<code>blog_rss_link</code>，豆瓣用户名<code>douban_name</code>（进入豆瓣个人主页，<a href="http://douban.com/people/username/%EF%BC%8C%E8%BF%99%E9%87%8C%E5%9C%B0%E5%9D%80%E4%B8%AD%E7%9A%84username%E5%B0%B1%E6%98%AF%E7%94%A8%E6%88%B7%E5%90%8D%EF%BC%89">douban.com/people/username/，这里地址中的username就是用户名）</a></p></li></ul><p>我的GitHub主页参考配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Social</span> <span class="string">Readme</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">schedule:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cron:</span> <span class="string">&#x27;0 0 * * *&#x27;</span></span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">update-social:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">zylele/social-readme@master</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">blog_rss_link:</span> <span class="string">https://zylele.github.io/atom.xml</span></span><br><span class="line">          <span class="attr">douban_name:</span> <span class="string">znyalor</span></span><br></pre></td></tr></table></figure><h2 id="非根目录readme文件构建使用方式"><a class="header-anchor" href="#非根目录readme文件构建使用方式">¶</a>非根目录readme文件构建使用方式</h2><p>如我的博客的源码仓库，其中 <a href="https://zylele.github.io/about/">关于我</a> 页面对应的仓库文件是<code>source/about/index.md</code></p><h3 id="1-修改目标文件"><a class="header-anchor" href="#1-修改目标文件">¶</a>1.修改目标文件</h3><p>同样的，在目标文件中插入上述的“识别点”</p><h3 id="2-配置workflow文件-v2"><a class="header-anchor" href="#2-配置workflow文件-v2">¶</a>2.配置workflow文件</h3><p>同样的，在仓库的工作流文件中增加workflow配置。</p><p>因为是更新非根目录的readme文件，则需要配置<code>file_path</code>参数来指定文件路径</p><p>这里我的配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Social</span> <span class="string">Readme</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">schedule:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cron:</span> <span class="string">&#x27;0 0 * * *&#x27;</span></span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">update-social:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">zylele/social-readme@master</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">douban_name:</span> <span class="string">znyalor</span></span><br><span class="line">          <span class="attr">file_path:</span> <span class="string">source/about/index.md</span></span><br></pre></td></tr></table></figure><h2 id="完整配置说明"><a class="header-anchor" href="#完整配置说明">¶</a>完整配置说明</h2><p>如果你想定制更多构建细节，在workflow文件中的<code>with</code>有如下可选参数</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">zylele/social-readme@master</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">blog_rss_link:</span> <span class="comment"># 博客链接</span></span><br><span class="line">    <span class="attr">blog_limit:</span> <span class="number">5</span> <span class="comment"># blog数量</span></span><br><span class="line">    <span class="attr">douban_name:</span> <span class="comment"># 豆瓣用户名</span></span><br><span class="line">    <span class="attr">douban_limit:</span> <span class="number">5</span> <span class="comment"># 豆瓣最新动态数量</span></span><br><span class="line">    <span class="attr">commit_message:</span> <span class="string">Updated</span> <span class="string">social</span> <span class="string">rss</span> <span class="string">by</span> <span class="string">social-readme</span> <span class="comment"># commit说明</span></span><br><span class="line">    <span class="attr">file_path:</span> <span class="comment"># 更新非readme文件，填写仓库中的文件路径，如source/about/index.md</span></span><br></pre></td></tr></table></figure><h2 id="Star-History"><a class="header-anchor" href="#Star-History">¶</a>Star History</h2><p><a href="https://star-history.com/#zylele/social-readme&amp;Date"><img src="https://api.star-history.com/svg?repos=zylele/social-readme&amp;type=Date" alt="Star History Chart"></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/zylele/social-readme&quot;&gt;social-readme&lt;/a&gt;，欢迎点个star～&lt;/p&gt;
&lt;p&gt;Automatically build Social feeds in your Profile Readme everyday, preview: &lt;a href=&quot;https://github.com/zylele&quot; target=&quot;_blank&quot;&gt;github.com/zylele&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;自动构建社交feed到你的主页readme中，预览：&lt;a href=&quot;https://github.com/zylele&quot; target=&quot;_blank&quot;&gt;github.com/zylele&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="GitHub" scheme="https://zylele.github.io/tags/GitHub/"/>
    
    <category term="持续集成" scheme="https://zylele.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>用Travis CI自动部署GitHub项目</title>
    <link href="https://zylele.github.io/2017/09/10/%E7%94%A8Travis%20CI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2GitHub%E9%A1%B9%E7%9B%AE/"/>
    <id>https://zylele.github.io/2017/09/10/%E7%94%A8Travis%20CI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2GitHub%E9%A1%B9%E7%9B%AE/</id>
    <published>2017-09-10T23:19:05.000Z</published>
    <updated>2025-11-01T01:16:14.348Z</updated>
    
    <content type="html"><![CDATA[<p>介绍一套免费持续集成构建部署解决方案。</p><p><img src="https://zylele.github.io/img/travis-ci/day-day-poor.jpg" alt="Poor Guy"></p><p>本文以部署基于Node.js的静态博客框架hexo为例</p><p>源码地址：<a href="https://github.com/zylele/blog">zylele/blog</a></p><span id="more"></span><h2 id="Travis-CI"><a class="header-anchor" href="#Travis-CI">¶</a>Travis CI</h2><p>顾名思义，Travis CI是一个持续集成(Continuous integration，简称CI)的工具。它可以在公共的Github仓库上免费使用。</p><blockquote><p>Travis CI 是目前新兴的开源持续集成构建项目，它与jenkins，GO的很明显的特别在于采用yaml格式，简洁清新独树一帜。目前大多数的github项目都已经移入到Travis CI的构建队列中，据说Travis CI每天运行超过4000次完整构建。</p></blockquote><h2 id="构建"><a class="header-anchor" href="#构建">¶</a>构建</h2><h3 id="在Github建立代码库"><a class="header-anchor" href="#在Github建立代码库">¶</a>在Github建立代码库</h3><p>首先，要在Github上建立一个代码仓库，要将自己hexo博客push到上面。hexo项目作为运行部署的项目，然后Github Page的项目作为部署的目标项目。</p><h3 id="开启Travis-CI"><a class="header-anchor" href="#开启Travis-CI">¶</a>开启Travis CI</h3><p>第二步，我们需要有一个Travis CI的账号，直接进入<a href="https://travis-ci.org/">Travis CI</a>官网，用自己的Github账号授权登录即可。</p><p>然后可以看到当前账号的所有代码仓库，接下来将博客项目的状态设置为启用。</p><p><img src="https://zylele.github.io/img/travis-ci/account.png" alt="turn on travis"></p><h3 id="创建SSH-key"><a class="header-anchor" href="#创建SSH-key">¶</a>创建SSH key</h3><p><strong>如果你的github已经配置过SSH了，可以省略这一步，或者你想缩小权限控制粒度，可继续执行这一步骤。</strong></p><p>第三步，创建一个部署在Travis CI上面的SSH key利用这个SSH key可以让Travis CI向我们自己的项目提交代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>得到<code>id_rsa.pub</code>和<code>id_rsa</code>，然后将有<code>pub</code>后缀的配置到Deploy key。</p><p><img src="https://zylele.github.io/img/travis-ci/deploy-key.png" alt="set deploy key"></p><p>记得要将<code>Allow write access</code>的选项选上，这样Travis CI才能获得push代码的权限。</p><h3 id="加密私钥"><a class="header-anchor" href="#加密私钥">¶</a>加密私钥</h3><p>刚才讲公钥文件配置好了，然后就要配置私钥文件，在hexo项目下面建立一个<code>.travis</code>的文件夹来放置需要配置的文件。</p><p>首先要安装travis命令行工具(如果在国内的网络环境下建议安装之前先<a href="https://ruby.taobao.org/">换源</a>)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install travis</span><br></pre></td></tr></table></figure><p>用命令行工具登录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ travis login --auto</span><br></pre></td></tr></table></figure><p>然后将刚刚生成的<code>id_rsa</code>复制到<code>.travis</code>文件夹，用命令行工具进行加密：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ travis encrypt-file id_rsa --add</span><br></pre></td></tr></table></figure><p>这个时候会生成加密之后的秘钥文件<code>id_rsa.enc</code>，原来的文件<code>id_rsa</code>就可以删掉了。</p><p>这时可以看到终端输出了一段</p><p><code>openssl aes-256-cbc -K $encrypted_xxxxxxxxxxx_key -iv $encrypted_xxxxxxxxxxx_iv</code></p><p>这样格式的信息，这是travis用来解密<code>id_rsa.enc</code>的key，先保存起来，后面配置<code>.travis.yml</code>会用到它。</p><p>为了让git默认连接SSH还要创建一个<code>ssh_config</code>文件。在<code>.travis</code>文件夹下创建一个<code>ssh_config</code>文件，输入以下内容：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Host</span> <span class="string">github.com</span></span><br><span class="line">    <span class="string">User</span> <span class="string">git</span></span><br><span class="line">    <span class="string">StrictHostKeyChecking</span> <span class="literal">no</span></span><br><span class="line">    <span class="string">IdentityFile</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">    <span class="string">IdentitiesOnly</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><p>现在进入travis CI设置页面</p><p><img src="https://zylele.github.io/img/travis-ci/setting.png" alt="travis setting"></p><p>可以看到刚刚travis命令行生成的解密key</p><p><img src="https://zylele.github.io/img/travis-ci/environment-variables.png" alt="environment variables"></p><p>顺便把上面的开关打开</p><p><img src="https://zylele.github.io/img/travis-ci/turn-on-build.png" alt="trun on travis setting"></p><p>这样，当向项目push代码的时候travis CI就会根据<code>.travis.yml</code>的内容去部署我们的项目了。</p><h3 id="travis-yml"><a class="header-anchor" href="#travis-yml">¶</a>.travis.yml</h3><p>最后就要配置<code>.travis.yml</code>。在项目的根目录创建<code>.travis.yml</code>文件。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置语言及相应版本</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span></span><br><span class="line"><span class="comment"># 项目所在分支</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"><span class="comment"># node_modules 缓存</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">node_modules</span></span><br><span class="line"><span class="comment"># 配置环境</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="comment"># 替换为刚才生成的解密信息</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="string">-K</span> <span class="string">$encrypted_xxxxxxxxx_key</span> <span class="string">-iv</span> <span class="string">$encrypted_xxxxxxxxx_iv</span> <span class="string">-in</span> <span class="string">.travis/id_rsa.enc</span> <span class="string">-out</span> <span class="string">~/.ssh/id_rsa</span> <span class="string">-d</span></span><br><span class="line"><span class="comment"># 改变文件权限</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line"><span class="comment"># 配置 ssh</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">eval</span> <span class="string">$(ssh-agent)</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">ssh-add</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">cp</span> <span class="string">.travis/ssh_config</span> <span class="string">~/.ssh/config</span></span><br><span class="line"><span class="comment"># 配置 git 替换为自己的信息</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&#x27;zylele&#x27;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="number">657345933</span><span class="string">@qq.com</span></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="comment"># 部署的命令</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span> <span class="string">-d</span></span><br></pre></td></tr></table></figure><p>好了现在只要向项目push代码就可以触发部署了，进入<a href="https://travis-ci.org">https://travis-ci.org</a>就可以看到部署的过程了。</p><h2 id="后记"><a class="header-anchor" href="#后记">¶</a>后记</h2><p>在部署了一遍之后发现，运行<code>npm install</code>安装node的库时候占据了部署的很大一部分时间，这里有一个技巧，可以将<code>node_modules</code>缓存起来，这样可以节省部署的时间。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># node_modules 缓存</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">node_modules</span></span><br></pre></td></tr></table></figure><h2 id="最后"><a class="header-anchor" href="#最后">¶</a>最后</h2><p><code>.travis.yml</code>的完整代码可以看我的<a href="https://github.com/zylele/blog/blob/master/.travis.yml">.travis.yml</a>文件。博客的完整代码可以看<a href="https://github.com/zylele/blog">这里</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍一套免费持续集成构建部署解决方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zylele.github.io/img/travis-ci/day-day-poor.jpg&quot; alt=&quot;Poor Guy&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文以部署基于Node.js的静态博客框架hexo为例&lt;/p&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/zylele/blog&quot;&gt;zylele/blog&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="持续集成" scheme="https://zylele.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>关于Spring Boot与Dubbo REST</title>
    <link href="https://zylele.github.io/2017/07/08/%E5%85%B3%E4%BA%8ESpring%20Boot%E4%B8%8EDubbo%20REST/"/>
    <id>https://zylele.github.io/2017/07/08/%E5%85%B3%E4%BA%8ESpring%20Boot%E4%B8%8EDubbo%20REST/</id>
    <published>2017-07-08T18:44:05.000Z</published>
    <updated>2025-11-01T01:16:14.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于Spring-Boot"><a class="header-anchor" href="#关于Spring-Boot">¶</a>关于Spring Boot</h2><p>Spring Boot的设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域成为领导者。</p><span id="more"></span><p>Spring Boot(英文中是“引导”的意思)，是用来简化Spring应用的搭建到开发的过程。应用开箱即用，只要通过 “just run”（可能是 java -jar 或 tomcat 或 maven插件run 或 shell脚本），就可以启动项目。二者，Spring Boot 只要很少的Spring配置文件（例如那些xml，property）。</p><p>因为“习惯优先于配置”的原则，使得Spring Boot在快速开发应用和微服务架构实践中得到广泛应用。</p><h2 id="Spring-Boot整合Dubbo实现SOA"><a class="header-anchor" href="#Spring-Boot整合Dubbo实现SOA">¶</a>Spring Boot整合Dubbo实现SOA</h2><p>Spring Boot对于作为微服务的框架来说</p><p>优点：</p><ul><li>嵌入式Tomcat、Jetty容器，无需部署war包</li><li>遵循&quot;习惯优于配置&quot;原则，只需很少的配置，大部分时候可以使用默认配置</li><li>项目快速搭建</li><li>丰富的和第三方框架无配置整合的jar包</li></ul><p>缺点：</p><ul><li>坑有些多, 文档略少</li><li>简单的背后蕴藏了较大的学习曲线</li></ul><p>Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，是阿里巴巴SOA服务化治理方案的核心框架，有以下几个特性</p><ul><li>远程通信，向本地调用一样调用远程方法。</li><li>集群容错</li><li>服务自动发现和注册，可平滑添加或者删除服务提供者。</li></ul><p>一般而言，我们常常暴露HTTP服务，并走JSON模式。但慢慢量大了，缺少一种SOA的治理方案。之后整合Dubbo服务治理方案实现SOA，这样可以暴露出Dubbo服务接口，提供给Dubbo消费者进行RPC调用。</p><p>可以看出，Dubbo才是应用服务化绝对的核心，在这过程中，Spring Boot扮演为Dubbo提供服务启动初始化入口，整合各种第三方框架，为Dubbo服务提供各组件支持的角色</p><p>所以，Spring Boot在已经部署Dubbo服务的情况下，只作为容器来说没有必要使用</p><hr><h2 id="Dubbo服务的开放"><a class="header-anchor" href="#Dubbo服务的开放">¶</a>Dubbo服务的开放</h2><h3 id="概述与应用场景"><a class="header-anchor" href="#概述与应用场景">¶</a>概述与应用场景</h3><p>以REST为例</p><p>Dubbo支持多种远程调用方式，基于简单的文本格式消息和通用的HTTP协议，使它具备极广的适用性，几乎所有语言和平台都对它提供支持，同时其学习和使用的门槛也较低。</p><p>在dubbo中支持REST，可以为当今多数主流的远程调用场景都带来（显著）好处：</p><blockquote><p>显著简化企业内部的异构系统之间的（跨语言）调用。此处主要针对这种场景：dubbo的系统做服务提供端，其他语言的系统（也包括某些不基于dubbo的java系统）做服务消费端，两者通过HTTP和文本消息进行通信。即使相比Thrift、ProtoBuf等二进制跨语言调用方案，REST也有自己独特的优势（详见后面讨论）</p></blockquote><blockquote><p>显著简化对外Open API（开放平台）的开发。既可以用dubbo来开发专门的Open API应用，也可以将原内部使用的dubbo service直接“透明”发布为对外的Open REST API（当然dubbo本身未来最好可以较透明的提供诸如权限控制、频次控制、计费等诸多功能）</p></blockquote><blockquote><p>显著简化手机（平板）APP或者PC桌面客户端开发。类似于2，既可以用dubbo来开发专门针对无线或者桌面的服务器端，也可以将原内部使用的dubbo service直接”透明“的暴露给手机APP或桌面程序。当然在有些项目中，手机或桌面程序也可以直接访问以上场景2中所述的Open API。</p></blockquote><blockquote><p>显著简化浏览器AJAX应用的开发。类似于2，既可以用dubbo来开发专门的AJAX服务器端，也可以将原内部使用的dubbo service直接”透明“的暴露给浏览器中JavaScript。当然，很多AJAX应用更适合与web框架协同工作，所以直接访问dubbo service在很多web项目中未必是一种非常优雅的架构。</p></blockquote><blockquote><p>为企业内部的dubbo系统之间（即服务提供端和消费端都是基于dubbo的系统）提供一种基于文本的、易读的远程调用方式。</p></blockquote><blockquote><p>一定程度简化dubbo系统对其它异构系统的调用。可以用类似dubbo的简便方式“透明”的调用非dubbo系统提供的REST服务（不管服务提供端是在企业内部还是外部）</p></blockquote><blockquote><p><strong>需要指出的是，我认为1～3是dubbo的REST调用最有价值的三种应用场景，并且我们为dubbo添加REST调用，其最主要到目的也是面向服务的提供端，即开发REST服务来提供给非dubbo的（异构）消费端。</strong></p></blockquote><h3 id="一些问题"><a class="header-anchor" href="#一些问题">¶</a>一些问题</h3><p>Dubbo REST的服务能和Dubbo注册中心、监控中心集成吗？</p><blockquote><p>可以的，而且是自动集成的，也就是你在dubbo中开发的所有REST服务都会自动注册到服务册中心和监控中心，可以通过它们做管理。</p></blockquote><blockquote><p>但是，只有当REST的消费端也是基于dubbo的时候，注册中心中的许多服务治理操作才能完全起作用。而如果消费端是非dubbo的，自然不受注册中心管理，所以其中很多操作是不会对消费端起作用的。</p></blockquote><p>Dubbo REST中如何实现负载均衡和容错（failover）？</p><blockquote><p>如果dubbo REST的消费端也是dubbo的，则Dubbo REST和其他dubbo远程调用协议基本完全一样，由dubbo框架透明的在消费端做load balance、failover等等。</p></blockquote><blockquote><p>如果dubbo REST的消费端是非dubbo的，甚至是非java的，则最好配置服务提供端的软负载均衡机制，目前可考虑用LVS、HAProxy、 Nginx等等对HTTP请求做负载均衡。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;关于Spring-Boot&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#关于Spring-Boot&quot;&gt;¶&lt;/a&gt;关于Spring Boot&lt;/h2&gt;
&lt;p&gt;Spring Boot的设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域成为领导者。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring Boot" scheme="https://zylele.github.io/tags/Spring-Boot/"/>
    
    <category term="Dubbo" scheme="https://zylele.github.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>开源dubbokeeper MySQL快速启动版</title>
    <link href="https://zylele.github.io/2017/04/01/%E4%BA%8C%E6%AC%A1%E5%BC%80%E6%BA%90dubbokeeper%20MySQL%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E7%89%88/"/>
    <id>https://zylele.github.io/2017/04/01/%E4%BA%8C%E6%AC%A1%E5%BC%80%E6%BA%90dubbokeeper%20MySQL%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E7%89%88/</id>
    <published>2017-04-01T21:44:05.000Z</published>
    <updated>2025-11-01T01:16:14.348Z</updated>
    
    <content type="html"><![CDATA[<p>github地址：<a href="https://github.com/zylele/dubbokeeper-mqs">dubbokeeper-mqs</a></p><h2 id="dubbokeeper-mqs是什么"><a class="header-anchor" href="#dubbokeeper-mqs是什么">¶</a>dubbokeeper-mqs是什么</h2><p>dubbokeeper-mqs是基于Spring mvc开发的社区版dubboadmin集成服务管理以及服务监控一体的DUBBO服务管理系统，自<a href="https://github.com/dubboclub/dubbokeeper">dubbokeeper</a>基础上整合而成的<strong>MySQL快速启动版</strong>，并新增服务预警接口、权限登录功能</p><p>dubbokeeper-mqs集成监控与展示，节省服务器资源，提供一键编译部署</p><span id="more"></span><h2 id="dubbokeeper-mqs包含哪些功能"><a class="header-anchor" href="#dubbokeeper-mqs包含哪些功能">¶</a>dubbokeeper-mqs包含哪些功能</h2><ul><li>应用管理</li><li>动态配置</li><li>统计信息</li><li>Dubbo服务监控</li><li>zookeeper信息查看</li><li>服务预警</li></ul><hr><p>执行数据库初始化脚本<code>application.sql</code>，数据库名可以自定义一个，编码采用utf-8</p><h2 id="服务预警"><a class="header-anchor" href="#服务预警">¶</a>服务预警</h2><p>注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者</p><p>修改<code>com.dubboclub.dk.alarm.impl.AlarmServiceImpl</code>的<code>void alarmHandle(URL url)</code>的实现即可(服务提供者全部宕掉后，将会触发该方法)，通过<code>url.getServiceInterface()</code>获取服务名，发送邮件、发送短信等</p><h2 id="部署"><a class="header-anchor" href="#部署">¶</a>部署</h2><p>只需配置<code>src/main/resources/dubbo.properties</code>与<code>pom.xml</code>的各属性值</p><p>打包部署到Tomcat启动</p><hr><p><img src="https://zylele.github.io/img/dubbokeeper-mqs/dubbokeeper-service.png" alt=""></p><p>动态配置</p><p><img src="https://zylele.github.io/img/dubbokeeper-mqs/dubbokeeper-dpc.png" alt=""></p><p>依赖关系</p><p><img src="https://zylele.github.io/img/dubbokeeper-mqs/dubbokeeper-monitor.png" alt=""></p><p>统计信息</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;github地址：&lt;a href=&quot;https://github.com/zylele/dubbokeeper-mqs&quot;&gt;dubbokeeper-mqs&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;dubbokeeper-mqs是什么&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#dubbokeeper-mqs是什么&quot;&gt;¶&lt;/a&gt;dubbokeeper-mqs是什么&lt;/h2&gt;
&lt;p&gt;dubbokeeper-mqs是基于Spring mvc开发的社区版dubboadmin集成服务管理以及服务监控一体的DUBBO服务管理系统，自&lt;a href=&quot;https://github.com/dubboclub/dubbokeeper&quot;&gt;dubbokeeper&lt;/a&gt;基础上整合而成的&lt;strong&gt;MySQL快速启动版&lt;/strong&gt;，并新增服务预警接口、权限登录功能&lt;/p&gt;
&lt;p&gt;dubbokeeper-mqs集成监控与展示，节省服务器资源，提供一键编译部署&lt;/p&gt;</summary>
    
    
    
    
    <category term="Dubbo" scheme="https://zylele.github.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbox快速指南</title>
    <link href="https://zylele.github.io/2017/03/07/dubbox%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97/"/>
    <id>https://zylele.github.io/2017/03/07/dubbox%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97/</id>
    <published>2017-03-07T21:44:05.000Z</published>
    <updated>2025-11-01T01:16:14.348Z</updated>
    
    <content type="html"><![CDATA[<p>该demo的github地址：<a href="https://github.com/zylele/dubbox-demo">dubbox-demo</a></p><h1>准备</h1><h2 id="依赖"><a class="header-anchor" href="#依赖">¶</a>依赖</h2><p>建议在maven安装目录下的<code>conf\settings.xml</code>的<code>&lt;mirrors&gt;</code>标签中添加如下镜像，以提高maven打包速度</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下载dubbox源码并且编译：<span id="more"></span></p><blockquote><p>git clone <a href="mailto:git@github.com">git@github.com</a>:dangdangdotcom/dubbox.git<br>执行maven命令<code>mvn clean install -Dmaven.test.skip</code></p></blockquote><h2 id="注册中心"><a class="header-anchor" href="#注册中心">¶</a>注册中心</h2><p>推荐使用Zookeeper注册中心</p><p><a href="http://dubbo.io/Administrator+Guide.htm#AdministratorGuide-ZookeeperRegistryInstallation">zookeeper安装</a></p><p>Zookeeper是Apacahe Hadoop的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbo服务的注册中心，工业强度较高，可用于生产环境，并推荐使用，参见：<a href="http://zookeeper.apache.org">Apache ZooKeeper</a></p><h2 id="接口定义与通用实体"><a class="header-anchor" href="#接口定义与通用实体">¶</a>接口定义与通用实体</h2><p>common工程只定义了服务提供者与消费者所依赖的接口与实体类</p><p>该工程下的接口与实体在服务提供方和消费方共享</p><h2 id="配置管理"><a class="header-anchor" href="#配置管理">¶</a>配置管理</h2><p>config工程只负责管理dubbo通用配置，在服务提供方和消费方共享，除此之外也可配置如数据库、缓存、队列等等</p><h1>快速启动</h1><h2 id="属性配置"><a class="header-anchor" href="#属性配置">¶</a>属性配置</h2><p>执行初始化init.sql</p><p>该demo基于springboot，以properties方式配置公共部分，xml配置各个服务不同之处</p><p>config工程引入依赖所需的jar</p><p>application.properties中加入注册中心配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo.registry.address=@dubbo.registry.address@</span><br></pre></td></tr></table></figure><p>具体值请修改pom不同环境打包的profile标签指定</p><p>config工程另外配置数据库，缓存等等，这里不再赘述</p><h2 id="服务提供者"><a class="header-anchor" href="#服务提供者">¶</a>服务提供者</h2><p>引入common与config</p><p>新建dubbo-config.xml,更多配置详情请参考<a href="http://dubbo.io/User+Guide-zh.htm#UserGuide-zh-%E9%85%8D%E7%BD%AE%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C">dubbo配置参考手册</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;base-user-service&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;$&#123;dubbo.registry.address&#125;&quot;</span> <span class="attr">file</span>=<span class="string">&quot;c:/dubbo/base-user-service.cache&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 通过注册中心发现监控中心服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">&quot;registry&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 扫描注解包路径，多个包用逗号分隔，不填pacakge表示扫描当前ApplicationContext中所有的类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">&quot;cn.zylele.base&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 服务提供者缺省值配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">timeout</span>=<span class="string">&quot;60000&quot;</span> <span class="attr">delay</span>=<span class="string">&quot;-1&quot;</span> <span class="attr">retries</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>服务提供者实现服务接口，这里的@Service的注解是dubbo的服务提供方注解，声明需要暴露的服务接口，并指定实现</p><p>注：服务既可以是提供者也可以是消费者，下面的DynamicQueryService为另一个服务。</p><p><code>@Reference</code>是dubbo的服务消费方注解，生成远程服务代理，来引用别的服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserQueryServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserQueryService</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference(check = false)</span></span><br><span class="line">    DynamicQueryService dynamicQueryService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(String userid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.getUser(userid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动入口，发布服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ImportResource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(value = &quot;classpath:*.xml&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceProvider</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">SpringApplication</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(UserServiceProvider.class);</span><br><span class="line">        app.setWebEnvironment(<span class="literal">false</span>);</span><br><span class="line">        app.run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务消费者"><a class="header-anchor" href="#服务消费者">¶</a>服务消费者</h2><p>引入common</p><p>application.properties中加入注册中心配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo.registry.address=@dubbo.registry.address@</span><br></pre></td></tr></table></figure><p>具体值请修改pom不同环境打包的profile标签指定</p><p>新建dubbo-config.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;base-consumer&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用zookeeper注册中心暴露发现服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;$&#123;dubbo.registry.address&#125;&quot;</span> <span class="attr">file</span>=<span class="string">&quot;c:/dubbo/base-consumer.cache&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通过注册中心发现监控中心服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">&quot;registry&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 扫描注解包路径，多个包用逗号分隔，不填pacakge表示扫描当前ApplicationContext中所有的类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:annotation</span> <span class="attr">package</span>=<span class="string">&quot;cn.zylele.base&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 关闭所有服务的启动时检查 check=false，总是会返回引用，当服务恢复时，能自动连上--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:consumer</span> <span class="attr">check</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>发现并调用远程服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    UserQueryService userQueryService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/user/get/&#123;userid&#125;&quot;,method=RequestMethod.GET, </span></span><br><span class="line"><span class="meta">        produces = MediaType.APPLICATION_JSON_VALUE)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">readUserInfo</span><span class="params">(<span class="meta">@PathVariable(&quot;userid&quot;)</span> String userid)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userQueryService.getUser(userid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动工程，调试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ImportResource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(value = &quot;classpath:dubbo-config.xml&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseConsumer</span> <span class="keyword">implements</span> <span class="title class_">EmbeddedServletContainerCustomizer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(BaseConsumer.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customize</span><span class="params">(ConfigurableEmbeddedServletContainer container)</span> &#123;</span><br><span class="line">        container.setPort(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>dubbox还具有相当多的配置功能，如负载均衡、集群容错，多协议、多注册中心等</p><p>更多示例与参考手册，可查看<a href="http://dubbo.io/User+Guide-zh.htm">dubbo用户指南</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;该demo的github地址：&lt;a href=&quot;https://github.com/zylele/dubbox-demo&quot;&gt;dubbox-demo&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;准备&lt;/h1&gt;
&lt;h2 id=&quot;依赖&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#依赖&quot;&gt;¶&lt;/a&gt;依赖&lt;/h2&gt;
&lt;p&gt;建议在maven安装目录下的&lt;code&gt;conf&#92;settings.xml&lt;/code&gt;的&lt;code&gt;&amp;lt;mirrors&amp;gt;&lt;/code&gt;标签中添加如下镜像，以提高maven打包速度&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;mirror&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;alimaven&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;aliyun maven&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;url&lt;/span&gt;&amp;gt;&lt;/span&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;url&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;mirrorOf&lt;/span&gt;&amp;gt;&lt;/span&gt;central&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;mirrorOf&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;mirror&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下载dubbox源码并且编译：</summary>
    
    
    
    
    <category term="Dubbox" scheme="https://zylele.github.io/tags/Dubbox/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot多数据源切换与事务控制</title>
    <link href="https://zylele.github.io/2016/09/04/Spring%20Boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E4%B8%8E%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/"/>
    <id>https://zylele.github.io/2016/09/04/Spring%20Boot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2%E4%B8%8E%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/</id>
    <published>2016-09-04T18:25:22.000Z</published>
    <updated>2025-11-01T01:16:14.348Z</updated>
    
    <content type="html"><![CDATA[<p>后台数据库读写分离，不光是要配置多个数据源，还得能灵活动态的切换数据源，很好，目前都没问题，然而如果你的应用是使用SpringBoot：</p><blockquote><p>SpringBoot使我们更容易去创建基于Spring的独立和产品级的可以“即时运行”的应用和服务。支持约定大于配置，目的是尽可能快地构建和运行Spring应用。</p></blockquote><p>来初始化构建你的工程，引入多数据源将可能会导致事务无效的问题<code>本文重点</code>。因为传统通过xml手动配置更精准，出错也容易查找原因，然而交给SpringBoot自动帮你完成大部分的配置，绝逼满满的都是坑(我的直觉</p><span id="more"></span><p>好，以下正题。</p><p>(本文持久层框架使用MyBatis)</p><ul><li>简单的架构是：单个数据源绑定给sessionFactory，再在Dao层操作</li></ul><p><img src="https://zylele.github.io/img/sprinboot-datasources/datasource.jpg" alt=""></p><ul><li>若多个数据源的话</li></ul><p><img src="https://zylele.github.io/img/sprinboot-datasources/datasources.jpg" alt=""></p><ul><li>sessionFactory都写死在了Dao层，若我再添加个数据源的话，则又得添加一个sessionFactory，这样并不能扩展嘛，所以</li></ul><p><img src="https://zylele.github.io/img/sprinboot-datasources/dynamic-datasources.jpg" alt=""></p><p>这样才是坠吼的！</p><h2 id="多数据源实现原理："><a class="header-anchor" href="#多数据源实现原理：">¶</a>多数据源实现原理：</h2><h3 id="配置文件"><a class="header-anchor" href="#配置文件">¶</a>配置文件</h3><p>精简篇幅，省略了无关本内容主题的配置</p><p>本工程关于数据源的配置在pom.xml，部署各种环境应用不同的数据源，测试两个数据库test1和test2的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">master.jdbc.driver</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">master.jdbc.driver</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- JDBC URL --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">master.jdbc.url</span>&gt;</span>jdbc:mysql://localhost/test1?useUnicode=true<span class="symbol">&amp;amp;</span>autoReconnect=true<span class="tag">&lt;/<span class="name">master.jdbc.url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库用户名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">master.jdbc.username</span>&gt;</span>root<span class="tag">&lt;/<span class="name">master.jdbc.username</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库密码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">master.jdbc.password</span>&gt;</span>root<span class="tag">&lt;/<span class="name">master.jdbc.password</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池最小连接数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">master.db.pool.min</span>&gt;</span>10<span class="tag">&lt;/<span class="name">master.db.pool.min</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池初始连接数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">master.db.pool.init</span>&gt;</span>10<span class="tag">&lt;/<span class="name">master.db.pool.init</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池最大连接数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">master.db.pool.max</span>&gt;</span>20<span class="tag">&lt;/<span class="name">master.db.pool.max</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slave.jdbc.driver</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">slave.jdbc.driver</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- JDBC URL --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slave.jdbc.url</span>&gt;</span>jdbc:mysql://localhost/test2?useUnicode=true<span class="symbol">&amp;amp;</span>autoReconnect=true<span class="tag">&lt;/<span class="name">slave.jdbc.url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库用户名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slave.jdbc.username</span>&gt;</span>root<span class="tag">&lt;/<span class="name">slave.jdbc.username</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库密码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slave.jdbc.password</span>&gt;</span>root<span class="tag">&lt;/<span class="name">slave.jdbc.password</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池最小连接数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slave.db.pool.min</span>&gt;</span>10<span class="tag">&lt;/<span class="name">slave.db.pool.min</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池初始连接数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slave.db.pool.init</span>&gt;</span>10<span class="tag">&lt;/<span class="name">slave.db.pool.init</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接池最大连接数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slave.db.pool.max</span>&gt;</span>20<span class="tag">&lt;/<span class="name">slave.db.pool.max</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>application.properties，由SpringBoot自动加载相关属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">master.datasource.name=masterDataSource</span><br><span class="line">master.datasource.url=@master.jdbc.url@</span><br><span class="line">master.datasource.username=@master.jdbc.username@</span><br><span class="line">master.datasource.password=@master.jdbc.password@</span><br><span class="line">master.datasource.driver-class-name=@master.jdbc.driver@</span><br><span class="line">master.datasource.max-idle=@master.db.pool.max@</span><br><span class="line">master.datasource.min-idle=@master.db.pool.min@</span><br><span class="line">master.datasource.initial-size=@master.db.pool.init@</span><br><span class="line">master.datasource.validation-query=select 1</span><br><span class="line">master.datasource.test-on-borrow=true</span><br><span class="line">master.datasource.test-while-idle=true</span><br><span class="line">slave.datasource.name=slaveDataSource</span><br><span class="line">slave.datasource.url=@slave.jdbc.url@</span><br><span class="line">slave.datasource.username=@slave.jdbc.username@</span><br><span class="line">slave.datasource.password=@slave.jdbc.password@</span><br><span class="line">slave.datasource.driver-class-name=@slave.jdbc.driver@</span><br><span class="line">slave.datasource.max-idle=@slave.db.pool.max@</span><br><span class="line">slave.datasource.min-idle=@slave.db.pool.min@</span><br><span class="line">slave.datasource.initial-size=@slave.db.pool.init@</span><br><span class="line">slave.datasource.validation-query=select 1</span><br><span class="line">slave.datasource.test-on-borrow=true</span><br><span class="line">slave.datasource.test-while-idle=true</span><br></pre></td></tr></table></figure><p>transaction.xml配置需要事务控制的service</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- AOP配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--pointcut元素定义一个切入点，execution中的第一个星号 用以匹配方法的返回类型，这里星号表明匹配所有返回类型。</span></span><br><span class="line"><span class="comment">    com.abc.dao.*.*(..)表明匹配com.abc.dao包下的所有类的所有方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;transactionPointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* cn.abc.lele.*.service.impl..*.*(..))&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--将定义好的事务处理策略应用到上述的切入点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;transactionPointCut&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--所有以find开头的方法都是只读的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;query*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;select*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;is*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;fill*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;count*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;insert*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;save*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;change*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;remove*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;clean*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;active*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;deactive*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;enable*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;disable*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;accept*&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--其他方法使用默认事务策略 propagation=&quot;NEVER&quot; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>  <span class="attr">propagation</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="扩展Spring的AbstractRoutingDataSource抽象类（该类充当了DataSource的路由中介-能有在运行时-根据某种key值来动态切换到真正的DataSource上。）"><a class="header-anchor" href="#扩展Spring的AbstractRoutingDataSource抽象类（该类充当了DataSource的路由中介-能有在运行时-根据某种key值来动态切换到真正的DataSource上。）">¶</a>扩展Spring的AbstractRoutingDataSource抽象类（该类充当了DataSource的路由中介, 能有在运行时, 根据某种key值来动态切换到真正的DataSource上。）</h3><p>查看源码，AbstractRoutingDataSource的声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractRoutingDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractDataSource</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span></span><br></pre></td></tr></table></figure><p>它继承了AbstractDataSource，而AbstractDataSource是javax.sql.DataSource的子类，分析它的getConnection方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">return</span> determineTargetDataSource().getConnection();  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException &#123;  </span><br><span class="line">    <span class="keyword">return</span> determineTargetDataSource().getConnection(username, password);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再查看determineTargetDataSource()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> DataSource <span class="title function_">determineTargetDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    Assert.notNull(<span class="built_in">this</span>.resolvedDataSources, <span class="string">&quot;DataSource router not initialized&quot;</span>);  </span><br><span class="line">    <span class="type">Object</span> <span class="variable">lookupKey</span> <span class="operator">=</span> determineCurrentLookupKey();</span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="built_in">this</span>.resolvedDataSources.get(lookupKey);</span><br><span class="line">    <span class="keyword">if</span> (dataSource == <span class="literal">null</span> &amp;&amp; (<span class="built_in">this</span>.lenientFallback || lookupKey == <span class="literal">null</span>)) &#123;</span><br><span class="line">        dataSource = <span class="built_in">this</span>.resolvedDefaultDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dataSource == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Cannot determine target DataSource for lookup key [&quot;</span> + lookupKey + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的重点是determineCurrentLookupKey()方法，这是AbstractRoutingDataSource类中的一个抽象方法，而它的返回值是你所要用的数据源dataSource的key值，有了这个key值，resolvedDataSource（这是个map,由配置文件中设置好后存入的）就从中取出对应的DataSource，如果找不到，就用配置默认的数据源</p><p>没错，要扩展AbstractRoutingDataSource类，并重写其中的determineCurrentLookupKey()方法，来实现数据源的切换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteSplitRoutingDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">determineCurrentLookupKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DbContextHolder.getDbType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DbContextHolder是我们封装的对数据源进行操作的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DbContextHolder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">DbType</span> &#123;</span><br><span class="line">        MASTER,</span><br><span class="line">        SLAVE</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DbType&gt; contextHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;DbType&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setDbType</span><span class="params">(DbType dbType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(dbType == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        contextHolder.set(dbType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DbType <span class="title function_">getDbType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> contextHolder.get() == <span class="literal">null</span> ? DbType.MASTER : contextHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clearDbType</span><span class="params">()</span> &#123;</span><br><span class="line">        contextHolder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的setDbType()什么时候执行呢？当然是在需要切换数据源的时候执行，应用面向切面，增加一个注解标签，在service层中需要切换数据源的方法上，写上注解标签，调用相应方法切换数据源，这里的@ReadOnlyConnection将在service层中切换到读库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ReadOnlyConnection &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加@Aspect的一个切面拦截类，切换数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadOnlyConnectionInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(ReadOnlyConnectionInterceptor.class);</span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(readOnlyConnection)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">proceed</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint, ReadOnlyConnection readOnlyConnection)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;set database connection to read only&quot;</span>);</span><br><span class="line">            DbContextHolder.setDbType(DbContextHolder.DbType.SLAVE);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proceedingJoinPoint.proceed();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            DbContextHolder.clearDbType();</span><br><span class="line">            logger.info(<span class="string">&quot;restore database connection&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据源加载与事务控制"><a class="header-anchor" href="#数据源加载与事务控制">¶</a>数据源加载与事务控制</h3><p>还记得上面那个由SpringBoot自动加载相关属性的application.properties么</p><p><strong>SpringBoot会自动根据application.properties将数据源属性前缀是spring.datasource配置<code>单数据源</code>，并且初始化相应的SqlSessionFactory(数据库session的连接工厂)与TransactionManager(事务管理器)</strong></p><p>这句话是重点，念三遍</p><p>所以，在多数据源的需求下，必须要我们手动初始化相应的bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &quot;cn.abc.lele.*.mapper&quot;, sqlSessionFactoryRef = &quot;sqlSessionFactory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext appContext;</span><br><span class="line">    <span class="comment">//初始化主库</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;masterDataSource&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;master.datasource&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">masterDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化从库</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;slaveDataSource&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;slave.datasource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">slaveDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化数据源bean，这个bean很重要，后面事务控制也会用到</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AbstractRoutingDataSource <span class="title function_">roundRobinDataSouceProxy</span><span class="params">(<span class="meta">@Qualifier(&quot;masterDataSource&quot;)</span>DataSource master,  <span class="meta">@Qualifier(&quot;slaveDataSource&quot;)</span> DataSource slave)</span> &#123;</span><br><span class="line">        <span class="type">ReadWriteSplitRoutingDataSource</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReadWriteSplitRoutingDataSource</span>();</span><br><span class="line">        Map&lt;Object, Object&gt; targetDataSources = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object, Object&gt;();</span><br><span class="line">        targetDataSources.put(DbContextHolder.DbType.MASTER, master);</span><br><span class="line">        targetDataSources.put(DbContextHolder.DbType.SLAVE,  slave);</span><br><span class="line">        proxy.setDefaultTargetDataSource(master);</span><br><span class="line">        proxy.setTargetDataSources(targetDataSources);</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化SqlSessionFactory，将自定义的多数据源ReadWriteSplitRoutingDataSource类实例注入到工厂中</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(<span class="meta">@Qualifier(&quot;masterDataSource&quot;)</span>DataSource master, <span class="meta">@Qualifier(&quot;slaveDataSource&quot;)</span> DataSource slave)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">SqlSessionFactoryBean</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();       </span><br><span class="line">        sessionFactory.setDataSource((DataSource)appContext.getBean(<span class="string">&quot;roundRobinDataSouceProxy&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> sessionFactory.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，启动工程，多数据源切换能正常执行，但是你会发现事务失效，这是为什么呢？</p><p>我们初始化了两个数据源，并且注入给SqlSessionFactory，所以对两个数据源切换并各自访问完全没有问题，让我们回顾一下上面的说过SpringBoot的一个作用：</p><p><strong>SpringBoot会自动根据application.properties将数据源属性前缀是spring.datasource配置<code>单数据源</code>，并且初始化相应的SqlSessionFactory(数据库session的连接工厂)与TransactionManager(事务管理器)</strong></p><p>所以，这里SpringBoot即使找到数据源属性前缀spring.datasource的数据源配置，也只是单数据源，这就是为什么多数据源切换正常执行，而事务失效的原因！</p><p>因为TransactionManager事务管理器里的dataSource根本不是我们的masterDataSource和slaveDataSource(我觉得应该是null，待验证</p><p>所以，必须手动初始化一个多数据源的TransactionManager，并且指定bean的名称与上面的transaction.xml中的<code>transaction-manager=&quot;transactionManager&quot;</code>一致！这样，Spring将会使用我们初始化之后的TransactionManager。</p><p>新增一个MyDataSourceTransactionManagerAutoConfiguration事务管理器，继承SpringBoot的jar包中DataSourceTransactionManagerAutoConfiguration自动配置数据源事务管理器类，并且构造注入我们初始化的数据源ReadWriteSplitRoutingDataSource的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDataSourceTransactionManagerAutoConfiguration</span> <span class="keyword">extends</span> <span class="title class_">DataSourceTransactionManagerAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext appContext;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义事务</span></span><br><span class="line"><span class="comment">     * MyBatis自动参与到spring事务管理中，无需额外配置，只要org.mybatis.spring.SqlSessionFactoryBean引用的数据源与DataSourceTransactionManager引用的数据源一致即可，否则事务管理会不起作用。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;transactionManager&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">transactionManagers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>((DataSource)appContext.getBean(<span class="string">&quot;roundRobinDataSouceProxy&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动工程，事务测试通过。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;后台数据库读写分离，不光是要配置多个数据源，还得能灵活动态的切换数据源，很好，目前都没问题，然而如果你的应用是使用SpringBoot：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SpringBoot使我们更容易去创建基于Spring的独立和产品级的可以“即时运行”的应用和服务。支持约定大于配置，目的是尽可能快地构建和运行Spring应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;来初始化构建你的工程，引入多数据源将可能会导致事务无效的问题&lt;code&gt;本文重点&lt;/code&gt;。因为传统通过xml手动配置更精准，出错也容易查找原因，然而交给SpringBoot自动帮你完成大部分的配置，绝逼满满的都是坑(我的直觉&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring Boot" scheme="https://zylele.github.io/tags/Spring-Boot/"/>
    
    <category term="事务" scheme="https://zylele.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>EJB与JNDI</title>
    <link href="https://zylele.github.io/2016/04/04/EJB%E4%B8%8EJNDI/"/>
    <id>https://zylele.github.io/2016/04/04/EJB%E4%B8%8EJNDI/</id>
    <published>2016-04-04T18:25:10.000Z</published>
    <updated>2025-11-01T01:16:14.348Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">应用驱动学习</blockquote>（摊手）<p>第一次接触使用EJB构建项目部署。</p><p><code>EJB</code>(Enterprise JavaBean)是sun的JavaEE服务器端组件模型和“<code>最佳实践</code>（讲真，即使EJB3.0已经借鉴了Spring等优点，在我看来还是臃肿繁琐），设计目标与核心应用是部署分布式应用程序。</p><blockquote><p>凭借java跨平台的优势，用EJB技术部署的分布式系统可以不限于特定的平台。EJB是J2EE的一部分，定义了一个用于开发基于组件的企业多重应用程序的标准。其特点包括网络服务支持和核心开发工具(SDK)。 在J2EE里，Enterprise Java Beans(EJB)称为Java企业Bean，是Java的核心代码，分别是会话Bean（Session Bean），实体Bean（Entity Bean）和消息驱动Bean（MessageDriven Bean）。</p></blockquote><span id="more"></span><p>作为Java WEB项目构建，可以简单这么理解其工作流程：</p><p><strong>JSP → Servlet → Session Bean或MessageDriven Bean → Entity Bean → DB持久化</strong></p><p>…</p><p>（Spring不知道比它高到哪里去了）</p><p><code>JNDI</code>(The Java Naming and Directory Interface，Java 命名和目录接口) 是一组在Java 应用中访问命名和目录服务的API。为开发人员提供了查找和访问各种命名和目录服务的通用、统一的方式。借助于JNDI 提供的接口，能够通过名字定位用户、机器、网络、对象服务等。</p><p>与EJB通信必须借助JNDI的命名服务查找使用相关的Bean，其中：</p><p>local是本地接口，remote是远程接口。web层调用app层使用remote接口。session bena和entity bean之间<br>调用使用的是local接口。</p><p>因为JNDI是一组接口，所以我们只需根据接口规范编程就可以。要通过JNDI 进行资源访问，我们必须设置初始化上下文的参数，主要是设置JNDI 驱动的类名(java.naming.factory.initial) 和提供命名服务的URL (java.naming.provider.url)。</p><p>因为Jndi 的实现产品有很多。所以java.naming.factory.initial 的值因提供JNDI 服务器的不同而不同，java.naming.provider.url 的值包括提供命名服务的主机地址和端口号。</p><p>访问Jboss 服务器的例子代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.setProperty(<span class="string">&quot;java.naming.factory.initial&quot;</span>, <span class="string">&quot;org.jnp.interfaces.NamingContextFactory&quot;</span>);</span><br><span class="line">props.setProperty(<span class="string">&quot;java.naming.provider.url&quot;</span>, <span class="string">&quot;localhost:1099&quot;</span>);</span><br><span class="line"><span class="type">InitialContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>(props);</span><br><span class="line"><span class="type">HelloWorld</span> <span class="variable">helloworld</span> <span class="operator">=</span> (HelloWorld) ctx.lookup(<span class="string">&quot;HelloWorldBean/remote&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不用说你也明白，remote接口对性能的影响是很大的。所以在设计的时候我们应尽量使用local接口，也就是facade模式。具体来说是，web层调用app层的session bean,session bean在调用各个实体entity bean。</p><p>local接口可以在与ejb同一个jvm环境中调用，但是不能对它进行远程调用的，在jndi查找的时候不能查找local home，而要查找remote home，也就是说需要实际进行RMI调用，而且必须提供Provider URL(例如t3://myserver:7001)，而且他们返回给客户的对象也不一样，local home创建的是javax.ejb.EJBLocalObject类型，它没有继承Remote interface；而Remote home创建的是javax.ejb.EJBObject类型的，它扩展了Remote。</p><p>实际上javax.ejb.EJBLoclObject型接口没有抛出RemoteException，因为对local类型接口的调用不是RMI，所以对Local接口的调用效率要高于对remote对象的调用，针对这点对EJB的设计提出以下建议：</p><ul><li><p>如果你的ejb客户只可能存在于与ejb相同app server，或者说同一个JVM环境中时，你可以只生成local类型接口（包括EJBHome 与EJBObject），如果你需要在与EJB容器不同的JVM环境中调用你的EJB的话，你必须生成Remote类型的接口（包括EJBHome 与EJBObject）。</p></li><li><p>在一般情况下建议两种类型的接口（包括EJBHome 与EJBObject）都生成，尤其是Session Bean，Entity Bean，可以只生成local类型的接口，如果想远程调用你的Entity Bean一般用Session Bean做代理。</p></li><li><p>如果你不是远程调用EJB的话，使用EJB时建议调用local接口，这样效率高，因为远程调用就意味着建立网络连接，效率必然不如local调用。</p></li><li><p>在Java EE 7中设计EJB时，默认情况下只给你生成local类型接口，所以你需要在设计EJB时把interfaces设成：local/remote，这样的话你的EJB至少会有5个java文件</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;应用驱动学习&lt;/blockquote&gt;
（摊手）
&lt;p&gt;第一次接触使用EJB构建项目部署。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;EJB&lt;/code&gt;(Enterprise JavaBean)是sun的JavaEE服务器端组件模型和“&lt;code&gt;最佳实践&lt;/code&gt;（讲真，即使EJB3.0已经借鉴了Spring等优点，在我看来还是臃肿繁琐），设计目标与核心应用是部署分布式应用程序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;凭借java跨平台的优势，用EJB技术部署的分布式系统可以不限于特定的平台。EJB是J2EE的一部分，定义了一个用于开发基于组件的企业多重应用程序的标准。其特点包括网络服务支持和核心开发工具(SDK)。 在J2EE里，Enterprise Java Beans(EJB)称为Java企业Bean，是Java的核心代码，分别是会话Bean（Session Bean），实体Bean（Entity Bean）和消息驱动Bean（MessageDriven Bean）。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="EJB" scheme="https://zylele.github.io/tags/EJB/"/>
    
  </entry>
  
  <entry>
    <title>浅谈依赖注入--Dependency Injection</title>
    <link href="https://zylele.github.io/2015/05/16/%E6%B5%85%E8%B0%88%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5--Dependency%20Injection/"/>
    <id>https://zylele.github.io/2015/05/16/%E6%B5%85%E8%B0%88%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5--Dependency%20Injection/</id>
    <published>2015-05-16T18:24:15.000Z</published>
    <updated>2025-11-01T01:16:14.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2><p><strong>Spring</strong>能有效地组织J2EE应用各层的对象。不管是控制层的Action对象，还是业务层的Service对象，还是持久层的DAO对象，都可在Spring的 管理下有机地协调、运行。Spring将各层的对象以<code>松耦合</code>的方式组织在一起，Action对象无须关心Service对象的具体实现，Service对 象无须关心持久层对象的具体实现，各层对象的调用<code>完全面向接口</code>。当系统需要重构时，代码的改写量将大大减少。</p><span id="more"></span><p>上面所说的一切都得宜于Spring的核心机制，<code>依赖注入</code>。</p><blockquote><p>依赖注入让bean与bean之间以配置文件组织在一起，而不是以硬编码的方式耦合在一起。</p></blockquote><p>依赖注入(Dependency Injection)和控制反转(Inversion of Control)是同一个概念。具体含义是:</p><blockquote><p>当某个角色(可能是一个Java实例，调用者)需要另一个角色(另一个Java实例，被调用者)的协助时，在传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在Spring里，创建被调用者的工作不再由调用者来完成，因此称为控制反转;创建被调用者实例的工作通常由Spring容器来完成，然后注入调用者，因此也称为依赖注入。</p></blockquote><p>不管是依赖注入，还是控制反转，都说明Spring采用动态、灵活的方式来管理各种对象。对象与对象之间的具体实现互相透明。在理解依赖注入之前，看如下这个问题在各种社会形态里如何解决:</p><p><strong><code>一个人</code>(Java实例，调用者)需要一把<code>斧子</code>(Java实例，被调用者)</strong></p><ul><li><p>原始社会里，几乎没有社会分工。需要斧子的人(调用者)只能自己去磨一把斧子(被调用者)。对应的情形为:Java程序里的调用者自己创建被调用者。</p></li><li><p>进入工业社会，工厂出现。斧子不再由普通人完成，而在工厂里被生产出来，此时需要斧子的人(调用者)找到工厂，购买斧子，无须关心斧子的制造过程。对应Java程序的简单工厂的设计模式。</p></li><li><p>进入“按需分配”社会，需要斧子的人不需要找到工厂，坐在家里发出一个简单指令:需要斧子。斧子就自然出现在他面前。对应Spring的依赖注入。</p></li></ul><p><em>第一种情况下，Java实例的调用者创建被调用的Java实例，必然要求被调用的Java类出现在调用者的代码里。无法实现二者之间的松耦合。</em></p><p><em>第二种情况下，调用者无须关心被调用者具体实现过程，只需要找到符合某种标准(接口)的实例，即可使用。此时调用的代码面向接口编程，可以让调用者和被调用者解耦，这也是工厂模式大量使用的原因。但调用者需要自己定位工厂，调用者与特定工厂耦合在一起。</em></p><p><em>第三种情况下，调用者无须自己定位工厂，程序运行到需要被调用者时，系统自动提供被调用者实例。事实上，调用者和被调用者都处于Spring的管理下，二者之间的依赖关系由Spring提供。</em></p><hr><h2 id="依赖注入方式"><a class="header-anchor" href="#依赖注入方式">¶</a>依赖注入方式</h2><p>所谓依赖注入，是指程序运行过程中，如果需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部的注入。Spring的依赖注入对调用者和被调用者几乎没有任何要求，完全支持对POJO之间依赖关系的管理。依赖注入通常有两种:</p><ul><li><p>设值注入。</p></li><li><p>构造注入。</p></li></ul><h3 id="设值注入"><a class="header-anchor" href="#设值注入">¶</a>设值注入</h3><p>设值注入是指通过setter方法传入被调用者的实例。这种注入方式简单、直观，因而在Spring的依赖注入里大量使用。看下面代码，是Person的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义Person接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//Person接口里定义一个使用斧子的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useAxe</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后是Axe的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义Axe接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Axe</span>&#123;</span><br><span class="line">    <span class="comment">//Axe接口里有个砍的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Person的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Chinese实现Person接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chinese</span> <span class="keyword">implements</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//面向Axe接口编程，而不是具体的实现类</span></span><br><span class="line">    <span class="keyword">private</span> Axe axe;</span><br><span class="line">    <span class="comment">//默认的构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chinese</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//设值注入所需的setter方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAxe</span><span class="params">(Axe axe)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.axe = axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现Person接口的useAxe方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useAxe</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Axe的第一个实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Axe的第一个实现类 StoneAxe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StoneAxe</span> <span class="keyword">implements</span> <span class="title class_">Axe</span>&#123;</span><br><span class="line">    <span class="comment">//默认构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StoneAxe</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//实现Axe接口的chop方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">chop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;石斧砍柴好慢&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面采用Spring的配置文件将Person实例和Axe实例组织在一起。配置文件如下所示:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring配置文件的根元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BEANS</span>&gt;</span></span><br><span class="line">&lt;!—定义第一bean，该bean的id是chinese, class指定该bean实例的实现类 --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">BEAN</span> <span class="attr">class</span>=<span class="string">lee.Chinese</span> <span class="attr">id</span>=<span class="string">chinese</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- property元素用来指定需要容器注入的属性，axe属性需要容器注入此处是设值注入，因此Chinese类必须拥有setAxe方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;axe&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 此处将另一个bean的引用注入给chinese bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">REF</span> <span class="attr">local</span>=<span class="string">&quot;”stoneAxe”/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">BEAN</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义stoneAxe bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BEAN</span> <span class="attr">class</span>=<span class="string">lee.StoneAxe</span> <span class="attr">id</span>=<span class="string">stoneAxe</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">BEANS</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从配置文件中，可以看到Spring管理bean的灵巧性。bean与bean之间的依赖关系放在配置文件里组织，而不是写在代码里。通过配置文件的 指定，Spring能精确地为每个bean注入属性。因此，配置文件里的bean的class元素，不能仅仅是接口，而必须是真正的实现类。</p><p>Spring会自动接管每个bean定义里的property元素定义。Spring会在执行无参数的构造器后、创建默认的bean实例后，调用对应 的setter方法为程序注入属性值。property定义的属性值将不再由该bean来主动创建、管理，而改为被动接收Spring的注入。</p><p>每个bean的id属性是该bean的惟一标识，程序通过id属性访问bean，bean与bean的依赖关系也通过id属性完成。</p><p>下面看主程序部分:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//因为是独立的应用程序，显式地实例化Spring的上下文。</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//通过Person bean的id来获取bean实例，面向接口编程，因此此处强制类型转换为接口类型</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person)ctx.getBean(<span class="string">&quot;chinese&quot;</span>);</span><br><span class="line">        <span class="comment">//直接执行Person的userAxe()方法。</span></span><br><span class="line">        p.useAxe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序的执行结果如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">石斧砍柴好慢</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主程序调用Person的useAxe()方法时，该方法的方法体内需要使用Axe的实例，但程序里<code>没有任何地方</code>将特定的Person实例和Axe实例<code>耦合</code>在一起。或者说，程序里没有为Person实例传入Axe的实例，Axe实例由Spring在运行期间动态注入。</p><p>Person实例不仅不需要了解Axe实例的具体实现，甚至无须了解Axe的创建过程。程序在运行到需要Axe实例的时候，Spring创建了Axe 实例，然后注入给需要Axe实例的调用者。Person实例运行到需要Axe实例的地方，自然就产生了Axe实例，用来供Person实例使用。</p><p>调用者不仅<code>无须关心被调用者的实现过程</code>，连工厂定位都可以省略(<s>真的是按需分配啊!</s>)。</p><p>如果需要改写Axe的实现类。或者说，提供另一个实现类给Person实例使用。Person接口、Chinese类都无须改变。只需提供另一个Axe的实现，然后对配置文件进行简单的修改即可。</p><p>Axe的另一个实现如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Axe的另一个实现类 SteelAxe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SteelAxe</span> <span class="keyword">implements</span> <span class="title class_">Axe</span>&#123;</span><br><span class="line">    <span class="comment">//默认构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SteelAxe</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//实现Axe接口的chop方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">chop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;钢斧砍柴真快&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，修改原来的Spring配置文件，在其中增加如下一行:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义一个steelAxe bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BEAN</span> <span class="attr">class</span>=<span class="string">lee.SteelAxe</span> <span class="attr">id</span>=<span class="string">steelAxe</span> /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该行重新定义了一个Axe的实现:SteelAxe。然后修改chinese bean的配置，将原来传入stoneAxe的地方改为传入steelAxe。也就是将</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">REF</span> <span class="attr">local</span>=<span class="string">&quot;”stoneAxe”/&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">REF</span> <span class="attr">local</span>=<span class="string">&quot;”steelAxe”/&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时再次执行程序，将得到如下结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">钢斧砍柴真快</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Person与Axe之间没有任何代码耦合关系，bean与bean之间的依赖关系由Spring管理。采用setter方法为目标bean注入属性的方式，称为设值注入。</p><p>业务对象的更换变得相当简单，对象与对象之间的依赖关系从代码里分离出来，通过配置文件动态管理。</p><h3 id="构造注入"><a class="header-anchor" href="#构造注入">¶</a>构造注入</h3><p>所谓构造注入，指通过构造函数来完成依赖关系的设定，而不是通过setter方法。对前面代码Chinese类做简单的修改，修改后的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Chinese实现Person接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chinese</span> <span class="keyword">implements</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//面向Axe接口编程，而不是具体的实现类</span></span><br><span class="line">    <span class="keyword">private</span> Axe axe;</span><br><span class="line">    <span class="comment">//默认的构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chinese</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//构造注入所需的带参数的构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chinse</span><span class="params">(Axe axe)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.axe = axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现Person接口的useAxe方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useAxe</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时无须Chinese类里的setAxe方法，构造Person实例时，Spring为Person实例注入所依赖的Axe实例。构造注入的配置文件也需做简单的修改，修改后的配置文件如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring配置文件的根元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BEANS</span>&gt;</span></span><br><span class="line">&lt;!—定义第一个bean，该bean的id是chinese, class指定该bean实例的实现类 --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">BEAN</span> <span class="attr">class</span>=<span class="string">lee.Chinese</span> <span class="attr">id</span>=<span class="string">chinese</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">BEAN</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义stoneAxe bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BEAN</span> <span class="attr">class</span>=<span class="string">lee.SteelAxe</span> <span class="attr">id</span>=<span class="string">steelAxe</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">BEANS</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行效果与使用steelAxe设值注入时的执行效果<code>完全一样</code>。区别在于:创建Person实例中Axe属性的<code>时机</code>不同——设值注入是现创建一个默认的bean实例，然后调用对应的构造方法注入依赖关系。而构造注入则在创建bean实例时，已经完成了依赖关系的。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#概述&quot;&gt;¶&lt;/a&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Spring&lt;/strong&gt;能有效地组织J2EE应用各层的对象。不管是控制层的Action对象，还是业务层的Service对象，还是持久层的DAO对象，都可在Spring的 管理下有机地协调、运行。Spring将各层的对象以&lt;code&gt;松耦合&lt;/code&gt;的方式组织在一起，Action对象无须关心Service对象的具体实现，Service对 象无须关心持久层对象的具体实现，各层对象的调用&lt;code&gt;完全面向接口&lt;/code&gt;。当系统需要重构时，代码的改写量将大大减少。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Spring" scheme="https://zylele.github.io/tags/Spring/"/>
    
    <category term="依赖注入" scheme="https://zylele.github.io/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>关于这个博客</title>
    <link href="https://zylele.github.io/2015/01/12/%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://zylele.github.io/2015/01/12/%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2/</id>
    <published>2015-01-12T18:19:05.000Z</published>
    <updated>2025-11-01T01:16:14.348Z</updated>
    
    <content type="html"><![CDATA[<p>好多事情都要自己去做的时候才知道会碰到很多问题。</p><blockquote class="blockquote-center">纸上得来终觉浅，绝知此事要躬行。</blockquote><p>以下都是免费开源的，任何人都可以使用和修改。</p><p>不同于wordpress，hexo由于需要使用Github，Git，Markdown，Node，js这样的工具，好多插件、widget都需要自己安装、设置。点击这个<a href="http://www.jianshu.com/p/465830080ea9">HEXO+Github,搭建属于自己的博客</a>或许会帮助到你。感谢issnan的<a href="https://github.com/iissnan/hexo-theme-next">NexT主题</a>。</p><span id="more"></span><p>GitHub是全球最大的开源代码托管网站，Github很好的将代码和社区联系在了一起，于是发生了很多有趣的事情，世界也因为他美好了一点点。Github作为现在最流行的代码仓库，已经得到很多大公司和项目的青睐，比如jQuery、Twitter等。</p><p>Github提供了Github Pages的服务，不仅可以方便的为项目建立介绍站点，允许用户自定义项目首页，用来替代默认的源码列表。也可以用来建立个人博客。</p><p>所以，GitHub Pages可以被认为是用户编写的、托管在GitHub上的静态网页。</p><p>hexo是一个基于Node.js的静态博客程序，可以方便的生成静态网页托管在GitHub和Heroku上。配合git版本控制系统，能方便提交内容更新到本地仓库，并远程部署到GitHub Pages上。</p><p>以上</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;好多事情都要自己去做的时候才知道会碰到很多问题。&lt;/p&gt;
&lt;blockquote class=&quot;blockquote-center&quot;&gt;纸上得来终觉浅，
绝知此事要躬行。&lt;/blockquote&gt;
&lt;p&gt;以下都是免费开源的，任何人都可以使用和修改。&lt;/p&gt;
&lt;p&gt;不同于wordpress，hexo由于需要使用Github，Git，Markdown，Node，js这样的工具，好多插件、widget都需要自己安装、设置。点击这个&lt;a href=&quot;http://www.jianshu.com/p/465830080ea9&quot;&gt;HEXO+Github,搭建属于自己的博客&lt;/a&gt;或许会帮助到你。感谢issnan的&lt;a href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;NexT主题&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="GitHub" scheme="https://zylele.github.io/tags/GitHub/"/>
    
    <category term="Hexo" scheme="https://zylele.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
